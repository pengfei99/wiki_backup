a:2:{s:7:"current";a:9:{s:4:"date";a:2:{s:7:"created";i:1588594513;s:8:"modified";i:1588671638;}s:7:"creator";s:11:"pengfei liu";s:4:"user";s:4:"pliu";s:11:"last_change";b:0;s:11:"contributor";a:1:{s:4:"pliu";s:11:"pengfei liu";}s:5:"title";s:30:"Understanding JVM Architecture";s:11:"description";a:2:{s:15:"tableofcontents";a:20:{i:0;a:4:{s:3:"hid";s:30:"understanding_jvm_architecture";s:5:"title";s:30:"Understanding JVM Architecture";s:4:"type";s:2:"ul";s:5:"level";i:1;}i:1;a:4:{s:3:"hid";s:17:"java_environments";s:5:"title";s:17:"Java Environments";s:4:"type";s:2:"ul";s:5:"level";i:2;}i:2;a:4:{s:3:"hid";s:14:"how_java_works";s:5:"title";s:14:"How Java Works";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:3;a:4:{s:3:"hid";s:16:"jvm_architecture";s:5:"title";s:16:"JVM Architecture";s:4:"type";s:2:"ul";s:5:"level";i:1;}i:4;a:4:{s:3:"hid";s:22:"class_loader_subsystem";s:5:"title";s:25:"1. Class Loader Subsystem";s:4:"type";s:2:"ul";s:5:"level";i:2;}i:5;a:4:{s:3:"hid";s:18:"runtime_data_areas";s:5:"title";s:21:"2. Runtime data areas";s:4:"type";s:2:"ul";s:5:"level";i:2;}i:6;a:4:{s:3:"hid";s:32:"method_area_shared_among_threads";s:5:"title";s:37:"2.1 Method area(Shared among threads)";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:7;a:4:{s:3:"hid";s:29:"heap_area_shared_among_thread";s:5:"title";s:34:"2.2 Heap area(Shared among Thread)";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:8;a:4:{s:3:"hid";s:21:"stack_area_per_thread";s:5:"title";s:26:"2.3 Stack area(per Thread)";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:9;a:4:{s:3:"hid";s:23:"pc_registers_per_thread";s:5:"title";s:28:"2.4 PC Registers(per Thread)";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:10;a:4:{s:3:"hid";s:30:"native_method_stack_per_thread";s:5:"title";s:36:"2.5 Native Method Stack (per Thread)";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:11;a:4:{s:3:"hid";s:16:"execution_engine";s:5:"title";s:19:"3. Execution engine";s:4:"type";s:2:"ul";s:5:"level";i:2;}i:12;a:4:{s:3:"hid";s:11:"interpreter";s:5:"title";s:15:"3.1 Interpreter";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:13;a:4:{s:3:"hid";s:25:"just-in-time_jit_compiler";s:5:"title";s:31:"3.2 Just-In-Time (JIT) Compiler";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:14;a:4:{s:3:"hid";s:20:"garbage_collector_gc";s:5:"title";s:26:"3.3 Garbage collector (GC)";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:15;a:4:{s:3:"hid";s:29:"jvm_performance_optimizations";s:5:"title";s:33:"3.4 JVM performance optimizations";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:16;a:4:{s:3:"hid";s:25:"java_native_interface_jni";s:5:"title";s:30:"4. Java Native Interface (JNI)";s:4:"type";s:2:"ul";s:5:"level";i:2;}i:17;a:4:{s:3:"hid";s:23:"native_method_libraries";s:5:"title";s:26:"5. Native Method Libraries";s:4:"type";s:2:"ul";s:5:"level";i:2;}i:18;a:4:{s:3:"hid";s:11:"jvm_threads";s:5:"title";s:11:"JVM Threads";s:4:"type";s:2:"ul";s:5:"level";i:1;}i:19;a:4:{s:3:"hid";s:10:"jvm_tuning";s:5:"title";s:10:"JVM Tuning";s:4:"type";s:2:"ul";s:5:"level";i:1;}}s:8:"abstract";s:472:"Understanding JVM Architecture

Java Environments

For almost any programming language, you need a specific environment which comprises of all the necessary components, application programming interfaces, and libraries in order to develop, compile, debug, and execute its programs. Java has 2 such environments and everyone working with Java has to start their work after setting up one of these environments on their local development or production environment platforms.";}s:8:"relation";a:2:{s:5:"media";a:3:{s:51:"employes:pengfei.liu:java:full_jvm_architecture.png";b:1;s:63:"employes:pengfei.liu:java:class_loader_delegation_hierarchy.png";b:1;s:41:"employes:pengfei.liu:java:stack_frame.png";b:1;}s:10:"firstimage";s:51:"employes:pengfei.liu:java:full_jvm_architecture.png";}s:8:"internal";a:2:{s:5:"cache";b:1;s:3:"toc";b:1;}}s:10:"persistent";a:5:{s:4:"date";a:2:{s:7:"created";i:1588594513;s:8:"modified";i:1588671638;}s:7:"creator";s:11:"pengfei liu";s:4:"user";s:4:"pliu";s:11:"last_change";b:0;s:11:"contributor";a:1:{s:4:"pliu";s:11:"pengfei liu";}}}