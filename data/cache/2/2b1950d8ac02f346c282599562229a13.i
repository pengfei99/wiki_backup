a:279:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:28:"Java job interview questions";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:45;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:44:"The basics of JAVA, jvm, and compile process";i:1;i:2;i:2;i:45;}i:2;i:45;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:45;}i:6;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:105;}i:7;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:43:"1. Java is a compile or interpret language?";i:1;i:3;i:2;i:105;}i:2;i:105;}i:8;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:105;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:105;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:"1. Java source code (use javac)";}i:2;i:161;}i:11;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:192;}i:12;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:" Java bytecode
2. Run bytecode on java run time environment";}i:2;i:194;}i:13;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:253;}i:14;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:253;}i:15;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"There are three way to run bytecode. ";}i:2;i:255;}i:16;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:293;}i:17;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:293;}i:18;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:293;}i:19;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:293;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:41:" JVM interpret java bytecode line by line";}i:2;i:297;}i:21;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:338;}i:22;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:338;}i:23;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:338;}i:24;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:338;}i:25;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:204:" The JIT(Just in time compiler) compiler is enabled by default, and is activated when a Java method is called. The JIT compiler compiles the bytecode of that method into native machine code, compiling it ";}i:2;i:342;}i:26;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:546;}i:27;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"just in time";}i:2;i:547;}i:28;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:559;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:" to run. When a method has been compiled, the JVM calls the compiled code of that method directly instead of interpreting it";}i:2;i:560;}i:30;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:684;}i:31;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:684;}i:32;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:684;}i:33;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:684;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:" RTSJ (Real time Specification for JAVA) is another type of java runtime environment. This is designed for real time programming. IBM WebSphere Real Time is an example";}i:2;i:688;}i:35;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:855;}i:36;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:855;}i:37;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:855;}i:38;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:855;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"Most of the java programe use the hotspot jvm (include a jvm and jit). RSTJ is used for real time devices only.";}i:2;i:857;}i:40;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:969;}i:41;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:969;}i:42;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"2. What is a JVM and hotspot?";i:1;i:3;i:2;i:969;}i:2;i:969;}i:43;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:969;}i:44;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:969;}i:45;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:340:"The JVM is by definition a virtual machine, that is a software machine that simulates what a real machine does. Like real machines it has an instruction set, a virtual computer architecture and an execution model. It is capable of running code written with this virtual instruction set, pretty much like a real machine can run machine code.";}i:2;i:1010;}i:46;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1350;}i:47;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1350;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:203:"HotSpot is an an implementation of the JVM concept, originally developed by Sun and now owned by Oracle. There are other implementations of the JVM specification, like JRockit, IBM J9, among many others.";}i:2;i:1352;}i:49;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1555;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1555;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:"The OpenJDK is a project under which an opensource implementation of the HotSpot (and many other things e.g compiler, JDK APIs, etc) is developed.";}i:2;i:1557;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1703;}i:53;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1705;}i:54;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"3. What is a JAVA AOT compiler?";i:1;i:3;i:2;i:1705;}i:2;i:1705;}i:55;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1705;}i:56;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1705;}i:57;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:"AOT is stand for ahead of time.";}i:2;i:1747;}i:58;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1778;}i:59;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1778;}i:60;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"To make a code run on a pc, you need to have runtime environment to run the code and warp system calls to the os.";}i:2;i:1780;}i:61;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1893;}i:62;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1893;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:175:"All programs have a runtime environment. Standard lib for C that wraps system calls to the operating system. Objective-C has its runtime that wraps all of its message passing.";}i:2;i:1895;}i:64;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2070;}i:65;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2070;}i:66;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:179:"With Java, the runtime is the JVM. Most of the Java implementations that people are familiar with are similar to the HotSpot JVM which is a byte code interpreter and JIT compiler.";}i:2;i:2072;}i:67;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2251;}i:68;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2251;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:413:"This doesn't have to be the only implementation. There is absolutely nothing saying you can't build a standard lib-esque runtime for Java and compile the code to native machine code and run that within the runtime that handles calls for new objects into mallocs and file access into system calls on the machine. And thats what the Ahead Of Time (AOT rather than JIT) compiler does. Call that runtime what you will";}i:2;i:2253;}i:70;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:2666;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:183:" you could call it a JVM implementation (and it does follow the JVM specification) or a runtime environment or standard lib for Java. Its there and it does essentially the same thing.";}i:2;i:2669;}i:72;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2852;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2852;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:309:"It could be done either by reimplementing javac to target the native machine (that's kind of what GCJ did). Or it could be done with translating the byte code generated by javac into machine (or byte) code for another machine - that's what Android does. Based on Wikipedia that's what Excelsior JET does too (";}i:2;i:2854;}i:75;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3163;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:126:"The compiler transforms the portable Java byte code into optimized executables for the desired hardware and operating system (";}i:2;i:3164;}i:77;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:3290;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:")";}i:2;i:3292;}i:79;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3293;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"), and the same is true for RoboVM.";}i:2;i:3294;}i:81;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3329;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3329;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:396:"There are additional complications with Java that means this is very hard to do as an exclusive approach. Dynamic loading of classes (class.forName()) or proxied objects require dynamics that AOT compilers do not easily provide and so their respective JVMs must also include either a JIT compiler (Excelsior JET) or an interpreter (GCJ) to handle classes that couldn't be precompiled into native.";}i:2;i:3331;}i:84;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3727;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3727;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"Remember, the JVM is a specification, with many implementations. The C standard library is also a specification with many different implementations.";}i:2;i:3729;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3877;}i:88;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3877;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:372:"With Java8, a fair bit of work has been done on AOT compilation. At best, one can only summarize AOT in general within the confines of textbox. However, in the JVM Language Summit for 2015 (August of 2015), there was a presentation: Java Goes AOT (youtube video). This video is 40 minutes long and goes into many of the deeper technical aspects and performance benchmarks.";}i:2;i:3879;}i:90;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4251;}i:91;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4254;}i:92;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"Java language syntax basics";i:1;i:2;i:2;i:4254;}i:2;i:4254;}i:93;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:4254;}i:94;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4295;}i:95;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:54:"1. What's the diff between final, finally and finalize";i:1;i:3;i:2;i:4295;}i:2;i:4295;}i:96;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4295;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4295;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:"1. Final is a keyword to apply restrictions on class, method and variable";}i:2;i:4361;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4435;}i:100;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:4435;}i:101;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4435;}i:102;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4435;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:" Final variable value can't be changed";}i:2;i:4439;}i:104;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4477;}i:105;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4477;}i:106;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4477;}i:107;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4477;}i:108;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:32:" Final method can't be overriden";}i:2;i:4481;}i:109;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4513;}i:110;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4513;}i:111;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4513;}i:112;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4513;}i:113;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" Final class can't be inherited";}i:2;i:4517;}i:114;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4548;}i:115;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4548;}i:116;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:4548;}i:117;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4548;}i:118;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:103:"2. Finally is a block to place important code, it will be executed whether exception is handled or not.";}i:2;i:4551;}i:119;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4654;}i:120;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4654;}i:121;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:"3. Finalize is a method which is used to perform clean up processing just before object is garbage collected.";}i:2;i:4656;}i:122;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4765;}i:123;a:3:{i:0;s:4:"file";i:1;a:3:{i:0;s:405:"
final int x=100;

try{  
int x=300;  
}
catch(Exception e){System.out.println(e);}  
finally{System.out.println("finally block is executed")

class FinalizeExample{  
public void finalize(){System.out.println("finalize called");}  
public static void main(String[] args){  
FinalizeExample f1=new FinalizeExample();  
FinalizeExample f2=new FinalizeExample();  
f1=null;  
f2=null;  
System.gc();  
}}  
";i:1;s:4:"java";i:2;N;}i:2;i:4773;}i:124;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5193;}i:125;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"The basics of JAVA data structure";i:1;i:2;i:2;i:5193;}i:2;i:5193;}i:126;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:5193;}i:127;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5240;}i:128;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:54:"1. Difference between ArrayList, LinkedList and Vector";i:1;i:3;i:2;i:5240;}i:2;i:5240;}i:129;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5240;}i:130;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5240;}i:131;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:57:":employes:pengfei.liu:java:java-collection-hierarchy.jpeg";i:1;s:0:"";i:2;N;i:3;s:3:"400";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:5306;}i:132;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5372;}i:133;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5372;}i:134;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:169:"From the hierarchy diagram, they all implement List interface. Their main difference is their implementation which causes different performance for different operations.";}i:2;i:5374;}i:135;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5544;}i:136;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:5544;}i:137;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5544;}i:138;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5544;}i:139;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:125:" ArrayList, is implemented as a resizable array. As more elements are added to ArrayList, its size is increased dynamically. ";}i:2;i:5548;}i:140;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5673;}i:141;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5673;}i:142;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5673;}i:143;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5673;}i:144;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:286:" LinkedList is implemented as a double linked list. Its performance on add and remove is better than Arraylist, but worse on get and set methods. LinkedList, however, also implements Queue interface which adds more methods than ArrayList and Vector, such as offer(), peek(), poll(), etc";}i:2;i:5677;}i:145;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5963;}i:146;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5963;}i:147;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5963;}i:148;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5963;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:272:" Vector is similar with ArrayList, but it is synchronized. ArrayList is a better choice if your program is thread-safe. Vector and ArrayList require space as more elements are added. Vector each time doubles its array size, while ArrayList grow 50% of its size each time. ";}i:2;i:5967;}i:150;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:6239;}i:151;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:6239;}i:152;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:6239;}i:153;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6243;}i:154;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"The basics of JAVA multithread";i:1;i:2;i:2;i:6243;}i:2;i:6243;}i:155;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:6243;}i:156;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6287;}i:157;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"1. Thread safety in JAVA";i:1;i:3;i:2;i:6287;}i:2;i:6287;}i:158;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6287;}i:159;a:3:{i:0;s:4:"file";i:1;a:3:{i:0;s:959:"
package org.pengfei.basic;

public class ThreadSafety {

    public static void main(String[] args) throws InterruptedException {

        ProcessingThread pt = new ProcessingThread();
        Thread t1 = new Thread(pt, "t1");
        t1.start();
        Thread t2 = new Thread(pt, "t2");
        t2.start();
        //wait for threads to finish processing
        t1.join();
        t2.join();
        System.out.println("Processing count="+pt.getCount());
    }

}

class ProcessingThread implements Runnable{
    private int count;

    @Override
    public void run() {
        for(int i=1; i < 5; i++){
            processSomething(i);
            count++;
        }
    }

    public int getCount() {
        return this.count;
    }

    private void processSomething(int i) {
        // processing some job
        try {
            Thread.sleep(i*1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
";i:1;s:4:"java";i:2;s:17:"ThreadSafety.java";}i:2;i:6328;}i:160;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6328;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:284:"The above code should show count=8, because each thread count 4 times and we have 2 thread. But, if you run the program, the possible result is 7,8,9. This happens because the count++ is not an atomic operation and two threads are not synchronized, these causeing the data corruption.";}i:2;i:7319;}i:162;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7603;}i:163;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7603;}i:164;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:174:"Thread safety in java is the process to make our program safe to use in multithreaded environment, there are different ways through which we can make our program thread safe.";}i:2;i:7605;}i:165;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7780;}i:166;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:7780;}i:167;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7780;}i:168;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7780;}i:169;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:" Synchronization is the easiest and most widely used tool for thread safety in java.";}i:2;i:7784;}i:170;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7868;}i:171;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7868;}i:172;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7868;}i:173;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7868;}i:174;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:" Use of Atomic Wrapper classes from java.util.concurrent.atomic package. For example AtomicInteger";}i:2;i:7872;}i:175;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7970;}i:176;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7970;}i:177;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7970;}i:178;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7970;}i:179;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:" Use of locks from java.util.concurrent.locks package.";}i:2;i:7974;}i:180;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8028;}i:181;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8028;}i:182;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8028;}i:183;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8028;}i:184;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:" Using thread safe collection classes, check this post for usage of ConcurrentHashMap for thread safety.";}i:2;i:8032;}i:185;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8136;}i:186;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8136;}i:187;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8136;}i:188;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8136;}i:189;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:" Using volatile keyword with variables to make every thread read the data from memory, not read from thread cache.";}i:2;i:8140;}i:190;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8254;}i:191;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8254;}i:192;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:8254;}i:193;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8257;}i:194;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"The basics of JAVA design pattern";i:1;i:2;i:2;i:8257;}i:2;i:8257;}i:195;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:8257;}i:196;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8303;}i:197;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:39:"1. What's the theory of Dynamic proxies";i:1;i:3;i:2;i:8303;}i:2;i:8303;}i:198;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:8303;}i:199;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8303;}i:200;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:157:"proxies are fronts or wrappers that pass function invocation through their own facilities (usually onto real methods)  potentially adding some functionality.";}i:2;i:8354;}i:201;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8511;}i:202;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8511;}i:203;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:366:"Dynamic proxies allow one single class with one single method to service multiple method calls to arbitrary classes with an arbitrary number of methods. A dynamic proxy can be thought of as a kind of Facade, but one that can pretend to be an implementation of any interface. Under the cover, it routes all method invocations to a single handler  the invoke() method.";}i:2;i:8513;}i:204;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8879;}i:205;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8879;}i:206;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"An more detail exmaple ";}i:2;i:8881;}i:207;a:3:{i:0;s:12:"internallink";i:1;a:2:{i:0;s:53:"employes:pengfei.liu:java:design_pattern:dynamicproxy";i:1;s:28:"Dynamic Proxy design pattern";}i:2;i:8904;}i:208;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8990;}i:209;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8992;}i:210;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"2. What is java reflection?";i:1;i:3;i:2;i:8992;}i:2;i:8992;}i:211;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:8992;}i:212;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8992;}i:213;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:208:"Reflection in Java is a very powerful concept and it’s of little use in normal programming but it’s the backbone for most of the Java, J2EE frameworks. Some of the frameworks that use java reflection are:";}i:2;i:9031;}i:214;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9240;}i:215;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:9240;}i:216;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9240;}i:217;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9240;}i:218;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:" JUnit  uses reflection to parse @Test annotation to get the test methods and then invoke it.";}i:2;i:9244;}i:219;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9337;}i:220;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9337;}i:221;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9337;}i:222;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9337;}i:223;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:" Spring  dependency injection, read more at Spring Dependency Injection";}i:2;i:9341;}i:224;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9412;}i:225;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9412;}i:226;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9412;}i:227;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9412;}i:228;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:" Tomcat web container to forward the request to correct module by parsing their web.xml files and request ";}i:2;i:9416;}i:229;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"URI";}i:2;i:9522;}i:230;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:9525;}i:231;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9526;}i:232;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9526;}i:233;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9526;}i:234;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9526;}i:235;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:" Eclipse auto completion of method names";}i:2;i:9530;}i:236;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9570;}i:237;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9570;}i:238;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9570;}i:239;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9570;}i:240;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" Struts";}i:2;i:9574;}i:241;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9581;}i:242;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9581;}i:243;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9581;}i:244;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9581;}i:245;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Hibernate";}i:2;i:9585;}i:246;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9595;}i:247;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9595;}i:248;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:9595;}i:249;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9595;}i:250;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:"The list is endless and they all use java reflection because all these frameworks have no knowledge and access of user defined classes, interfaces, their methods etc.";}i:2;i:9597;}i:251;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9763;}i:252;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9763;}i:253;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:141:"We should not use reflection in normal programming where we already have access to the classes and interfaces because of following drawbacks.";}i:2;i:9765;}i:254;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9907;}i:255;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:9907;}i:256;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9907;}i:257;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9907;}i:258;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:175:" Poor Performance  Since java reflection resolve the types dynamically, it involves processing like scanning the classpath to find the class to load, causing slow performance.";}i:2;i:9911;}i:259;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10086;}i:260;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10086;}i:261;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10086;}i:262;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10086;}i:263;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:213:" Security Restrictions  Reflection requires runtime permissions that might not be available for system running under security manager. This can cause you application to fail at runtime because of security manager.";}i:2;i:10090;}i:264;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10303;}i:265;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10303;}i:266;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10303;}i:267;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10303;}i:268;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:261:" Security Issues  Using reflection we can access part of code that we are not supposed to access, for example we can access private fields of a class and change it’s value. This can be a serious security threat and cause your application to behave abnormally.";}i:2;i:10307;}i:269;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10568;}i:270;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10568;}i:271;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10568;}i:272;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10568;}i:273;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:220:" High Maintenance  Reflection code is hard to understand and debug, also any issues with the code can’t be found at compile time because the classes might not be available, making it less flexible and hard to maintain.";}i:2;i:10572;}i:274;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10792;}i:275;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10792;}i:276;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:10792;}i:277;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10794;}i:278;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:10794;}}