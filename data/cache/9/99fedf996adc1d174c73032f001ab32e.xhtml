
<h1 class="sectionedit1" id="understanding_java_garbage_collection">Understanding Java Garbage Collection</h1>
<div class="level1">

<p>
Java garbage collection is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a Java Virtual Machine(JVM). When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory.
</p>

<p>
To tune the performance of JVM. There are three key stages:
</p>
<ul>
<li class="level1"><div class="li"> Heap memory and perm gen optimization: Change the size of young, old and permanent generation(not in heap), to avoid memory overflow, and reduce the frequency of GC </div>
</li>
<li class="level1"><div class="li"> JIT optimization: configure how JIT choose which code (often frequently called code) to compile because compiling and storing compiled code in the cache memory cost a lot.</div>
</li>
<li class="level1"><div class="li"> GC optimization:</div>
</li>
</ul>

<p>
So, understanding how the GC works can help you to tune the performance of your java application.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Understanding Java Garbage Collection&quot;,&quot;hid&quot;:&quot;understanding_java_garbage_collection&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-1021&quot;} -->
<h2 class="sectionedit2" id="how_gc_works">1. How GC works</h2>
<div class="level2">

<p>
Java Garbage Collector runs as a Daemon Thread (i.e. a low priority thread that runs in the background to provide services to user threads or perform JVM tasks). From time to time, it looks into all the objects in Heap memory and identifies objects that are no longer referenced by any part of your program (such unreferenced objects can no longer be reachable by the application code). Then all these unreferenced objects are destroyed and space will be reclaimed for newly-creating objects.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;1. How GC works&quot;,&quot;hid&quot;:&quot;how_gc_works&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;1022-1544&quot;} -->
<h3 class="sectionedit3" id="reachabiility_of_an_object">1.1 Reachabiility of an object</h3>
<div class="level3">

<p>
Informally, an object is reachable if it is referenced by at least one variable in the program, either directly or through references from other reachable objects. More precisely, objects can be reachable in only two ways:
</p>
<ul>
<li class="level1"><div class="li"> A distinguished set of roots: objects that are assumed to be reachable. Typically, these include all the objects referenced from anywhere in the call stack (that is, all local variables and parameters in the functions currently being invoked) and any global variables.</div>
</li>
<li class="level1"><div class="li"> Anything referenced from a reachable object is itself reachable; more formally, reachability is a transitive closure.</div>
</li>
</ul>

<p>
The reachability definition of “garbage” is not optimal, insofar as the last time a program uses an object could be long before that object falls out of the environment scope. A distinction is sometimes drawn between <strong>syntactic garbage</strong>, those objects the program cannot possibly reach, and <strong>semantic garbage</strong>, those objects the program will in fact never again use. For example:
</p>
<pre class="code">Object x = new Foo();
Object y = new Bar();
x = new Quux();
/* At this point, we know that the Foo object 
 * originally assigned to x will never be
 * accessed: it is syntactic garbage.
 */

if (x.check_something()) {
    x.do_something(y);
}
System.exit(0);
/* In the above block, y *could* be semantic garbage;
 * but we won&#039;t know until x.check_something() returns
 * some value -- if it returns at all. If x.check_something() 
 * depends on user input, then we only know it at runtime.
 */</pre>

<p>
With the above example, we can easily conclude that the problem of precisely identifying semantic garbage is partially decidable.
</p>

<p>
An object can immediately become unreachable if one of the following cases occurs (no need to wait for generational aging in the Heap).
</p>
<ul>
<li class="level1"><div class="li"> Nullifying the reference variable</div>
</li>
<li class="level1"><div class="li"> Re-assigning the reference variable</div>
</li>
<li class="level1"><div class="li"> Object created inside method</div>
</li>
<li class="level1"><div class="li"> Anonymous object</div>
</li>
<li class="level1"><div class="li"> Objects with only internal references (Island of Isolation)</div>
</li>
</ul>

</div>

<h4 id="nullifying_the_reference_variable">1.1.1 Nullifying the reference variable</h4>
<div class="level4">

<p>
When a reference variable of an object are changed to NULL, the object becomes unreachable and eligible for GC.
</p>
<pre class="code">//create an object, the constructor returns a reference of the object, and we assign it to obj
Object obj=new Object();


// after some work, we want to delete the object, because we don&#039;t need it anymore.

// this makes obj eligible for gc
obj=null

// remember jvm doesn&#039;t guarantee garbage collection happens when you call System.gc() or Runtime.getRuntime().gc(). It&#039;s managed by the JVM. 
System.gc() </pre>

<p>
Another case is that the object has never been assigned to a reference after creation. We can call it <strong>Anonymous object</strong>
</p>
<pre class="code">// new operator dynamically allocates memory for an object and returns a reference to it
new Person(&quot;John Doe&quot;);
 
// object cannot be used since no variable assignment, thus it becomes eligible for gc</pre>

</div>

<h4 id="re-assigning_the_reference_variable">1.1.2 Re-assigning the reference variable</h4>
<div class="level4">

<p>
When a reference id of one object is referenced to a reference id of some other object, then the previous object will have no reference to it any longer. The object becomes unreachable and eligible for GC.
</p>
<pre class="code">//create an object, the constructor returns a reference of the object, and we assign it to obj
Object obj1=new Object(&quot;obj1&quot;);
Object obj2=new Object(&quot;obj2&quot;);

// after some work, we want to delete the obj1, because we don&#039;t need it anymore.

// this makes obj1 eligible for gc, because of no reference links to object obj1.

obj1=obj2

// remember jvm doesn&#039;t guarantee garbage collection happens when you call System.gc() or Runtime.getRuntime().gc(). It&#039;s managed by the JVM. 
System.gc() </pre>

</div>

<h4 id="object_created_inside_method">1.1.3 Object created inside method</h4>
<div class="level4">

<p>
In a thread, methods are stored inside a Stack in LIFO (Last In — First Out) order. When such a method is popped out from the Stack, all its members die and if some objects were created inside it, then these objects also become unreachable, thus eligible for GC.
</p>
<pre class="code java"><span class="kw1">class</span> PersonTest <span class="br0">&#123;</span>    
    <span class="kw1">static</span> <span class="kw4">void</span> createMale<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co1">//object p1 inside method becomes unreachable after createMale() completes</span>
        Person p1 <span class="sy0">=</span> <span class="kw1">new</span> Person<span class="br0">&#40;</span><span class="st0">&quot;John Doe&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
        createFemale<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// calling garbage collector</span>
        <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+system"><span class="kw3">System</span></a>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span><span class="st0">&quot;GC Call inside createMale()&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+system"><span class="kw3">System</span></a>.<span class="me1">gc</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// p2 will be garbage-collected</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">static</span> <span class="kw4">void</span> createFemale<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co1">//object p2 inside method becomes unreachable after createFemale() completes</span>
        Person p2 <span class="sy0">=</span> <span class="kw1">new</span> Person<span class="br0">&#40;</span><span class="st0">&quot;Jane Doe&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> main<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> args<span class="br0">&#91;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        createMale<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// calling garbage collector</span>
        <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+system"><span class="kw3">System</span></a>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span><span class="st0">&quot;<span class="es0">\n</span>GC Call inside main()&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+system"><span class="kw3">System</span></a>.<span class="me1">gc</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// p1 will be garbage-collected</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

</div>

<h4 id="objects_with_only_internal_references_island_of_isolation">1.1.4 Objects with only internal references (Island of isolation)</h4>
<div class="level4">

<p>
Carefully observe how the following two objects lose their external references. Even the two objects are referenced to each other, but as they lose their external references, they become eligible for GC.
</p>

<p>
<a href="/lib/exe/detail.php?id=employes%3Apengfei.liu%3Ajava%3Ajava_gc&amp;media=employes:pengfei.liu:java:isolation_island.png" class="media" title="employes:pengfei.liu:java:isolation_island.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=4b8d46&amp;media=employes:pengfei.liu:java:isolation_island.png" class="media" alt="" width="400" /></a>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;1.1 Reachabiility of an object&quot;,&quot;hid&quot;:&quot;reachabiility_of_an_object&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:3,&quot;range&quot;:&quot;1545-6706&quot;} -->
<h3 class="sectionedit4" id="a_simple_approach_to_describe_java_gc">1.2 A simple approach to describe Java GC</h3>
<div class="level3">

<p>
Each JVM implementation can have its own GC implementation, the only requirement is that the GC meets the JVM specification. And a JVM can propose many GC collectors. But, all its garbage collectors follow the same basic process
</p>
<ol>
<li class="level1"><div class="li"> Mark: Identifying objects that are currently in use and not in use</div>
</li>
<li class="level1"><div class="li"> Deletion: <strong>Normal Deletion</strong> which Removes the unused objects and reclaims the free space. <strong>Deletion with Compacting</strong> which moves all the survived objects to one survivor space, so remaining objects are in a contiguous block at the start of the heap. The compaction process makes it easier to allocate memory to new objects sequentially after the block of memory allocated to existing objects.</div>
</li>
</ol>

<p>
However, this approach has the following issues:
</p>
<ul>
<li class="level1"><div class="li"> Not efficient because by nature most of the newly created objects will become unused</div>
</li>
<li class="level1"><div class="li"> Long-lived objects are most likely to be in use for future GC cycles too</div>
</li>
</ul>

<p>
To solve the above issues, in reality, objects are stored in separate generational spaces of the Heap in a way that each generational space indicates the lifetime of objects stored in it. Then, the garbage collection happens in 2 major phases called <strong>Minor GC</strong> and <strong>Major GC</strong> and objects are scanned and moved among generational spaces before complete deletion. See Heap memory section in <a href="/doku.php?id=employes:pengfei.liu:java:java_memory_model" class="wikilink1" title="employes:pengfei.liu:java:java_memory_model">Java Memory Model</a> for more details.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;1.2 A simple approach to describe Java GC&quot;,&quot;hid&quot;:&quot;a_simple_approach_to_describe_java_gc&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:4,&quot;range&quot;:&quot;6707-8156&quot;} -->
<h3 class="sectionedit5" id="mark_and_sweep_implementation_strategy">1.3 Mark and Sweep implementation strategy</h3>
<div class="level3">

<p>
All garbage collectors in Oracle hotSpot JVM implements the “Mark and Sweep” implementation strategy.
</p>
<ol>
<li class="level1"><div class="li"> <strong>Mark</strong>: It identifies and marks all object references (starting with the GC roots) that are still used and reachable (a.k.a. live objects), and the rest is considered garbage.</div>
</li>
<li class="level1"><div class="li"> <strong>Sweep</strong>: It removes not reachable objects identified by the “mark”. It traverses Heap and finds unoccupied spaces between the live objects, these spaces are recorded in a free list and are made available for future object allocation.</div>
</li>
</ol>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;1.3 Mark and Sweep implementation strategy&quot;,&quot;hid&quot;:&quot;mark_and_sweep_implementation_strategy&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:5,&quot;range&quot;:&quot;8157-8736&quot;} -->
<h3 class="sectionedit6" id="java_garbage_collection_roots">1.4 Java Garbage Collection Roots</h3>
<div class="level3">

<p>
For your application code to reach an object in Heap memory, there should be a root object which is connected to your object(inside the heap) and your code(outside the heap). Such root objects that are accessible from outside the Heap are called Garbage Collection (GC) roots. There are several types of GC roots such as Local variables, Active Java threads, Static variables, JNI References, etc.. (Just take the idea of GC roots here, if you do a quick google search, you may find many conflicting classifications of GC roots). What we need to learn here is that as long as our object is directly or indirectly referenced by one of these GC roots and the GC root remains alive, our object can be considered as a reachable object. The moment our object loses its reference to a GC root, it becomes unreachable, hence eligible for garbage collection.
</p>

<p>
Below figure shows an example of GC roots
</p>

<p>
<a href="/lib/exe/detail.php?id=employes%3Apengfei.liu%3Ajava%3Ajava_gc&amp;media=employes:pengfei.liu:java:gc_roots.png" class="media" title="employes:pengfei.liu:java:gc_roots.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=5a86f9&amp;media=employes:pengfei.liu:java:gc_roots.png" class="media" alt="" width="400" /></a>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;1.4 Java Garbage Collection Roots&quot;,&quot;hid&quot;:&quot;java_garbage_collection_roots&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:6,&quot;range&quot;:&quot;8737-9728&quot;} -->
<h2 class="sectionedit7" id="advantage_and_disadvantages_of_gc">2 Advantage and disadvantages of GC</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;2 Advantage and disadvantages of GC&quot;,&quot;hid&quot;:&quot;advantage_and_disadvantages_of_gc&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:7,&quot;range&quot;:&quot;9729-9777&quot;} -->
<h3 class="sectionedit8" id="advantages">2.1 Advantages:</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> No manual memory allocation/deallocation handling because unused memory space is automatically handled by GC</div>
</li>
<li class="level1"><div class="li"> No overhead of handling Dangling Pointer</div>
</li>
<li class="level1"><div class="li"> Automatic Memory Leak management (GC on its own can&#039;t guarantee the full proof solution to memory leaking, however, it takes care of a good portion of it)</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;2.1 Advantages:&quot;,&quot;hid&quot;:&quot;advantages&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:8,&quot;range&quot;:&quot;9778-10124&quot;} -->
<h3 class="sectionedit9" id="disadvantages">2.2 Disadvantages:</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Since JVM has to keep track of object reference creation/deletion, this activity requires more CPU power besides the original application. It may affect the performance of requests which required large memory</div>
</li>
<li class="level1"><div class="li"> Programmers have no control over the scheduling of CPU time dedicated to freeing objects that are no longer needed</div>
</li>
<li class="level1"><div class="li"> Using some GC implementations might result in application stopping unpredictably(e.g. stop-the-world gc)</div>
</li>
<li class="level1"><div class="li"> Automatized memory management will not be as efficient as the proper manual memory allocation/deallocation</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;2.2 Disadvantages:&quot;,&quot;hid&quot;:&quot;disadvantages&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:9,&quot;range&quot;:&quot;10125-10708&quot;} -->
<h2 class="sectionedit10" id="java_garbage_collectors">3.Java Garbage Collectors</h2>
<div class="level2">

<p>
There are many garbage collectors implementation, they use different strategies and algorithms. Here, I only highlight some common used strategies. For more details, please go visit <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" class="urlextern" title="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="nofollow">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;3.Java Garbage Collectors&quot;,&quot;hid&quot;:&quot;java_garbage_collectors&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:10,&quot;range&quot;:&quot;10709-10987&quot;} -->
<h3 class="sectionedit11" id="implementation_strategies_in_garbage_collection">3.1 Implementation strategies in garbage collection</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Moving vs non-moving</div>
</li>
<li class="level1"><div class="li"> Copying vs. mark-and-sweep vs. mark-and-don&#039;t-sweep</div>
</li>
<li class="level1"><div class="li"> Generational GC (ephemeral GC)</div>
</li>
<li class="level1"><div class="li"> Precise vs. conservative and internal pointers</div>
</li>
<li class="level1"><div class="li"> Stop-the-world vs. incremental vs. concurrent</div>
</li>
</ul>

<p>
Here, we only highlight Stop-the-world vs. incremental vs. concurrent
</p>

</div>

<h4 id="stop-the-world_vs_incremental_vs_concurrent">Stop-the-world vs. incremental vs. concurrent</h4>
<div class="level4">

<p>
Incremental and concurrent garbage collectors are designed to reduce this disruption by interleaving their work with activity from the main program.
</p>

</div>

<h5 id="stop-the-world">stop-the-world</h5>
<div class="level5">

<p>
<strong>stop-the-world</strong> garbage collectors completely halt the execution of the program to run a collection cycle, thus guaranteeing that new objects are not allocated and objects do not suddenly become unreachable while the collector is running.
</p>

<p>
This has the obvious disadvantage that the program can perform no useful work while a collection cycle is running (sometimes called the “embarrassing pause”). Stop-the-world garbage collection is therefore mainly suitable for non-interactive programs. Its advantage is that it is both simpler to implement and faster than incremental garbage collection.
</p>

</div>

<h5 id="incremental_garbage_collectors">Incremental garbage collectors</h5>
<div class="level5">

<p>
<strong>Incremental</strong> garbage collectors perform the garbage collection cycle in discrete phases, with program execution permitted between each phase (and sometimes during some phases). 
</p>

</div>

<h5 id="concurrent_garbage_collectors">Concurrent garbage collectors</h5>
<div class="level5">

<p>
<strong>Concurrent</strong> garbage collectors do not stop program execution at all, except perhaps briefly when the program&#039;s execution stack is scanned. However, the sum of the incremental phases takes longer to complete than one batch garbage collection pass, so these garbage collectors may yield lower total throughput.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;3.1 Implementation strategies in garbage collection&quot;,&quot;hid&quot;:&quot;implementation_strategies_in_garbage_collection&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:11,&quot;range&quot;:&quot;10988-12734&quot;} -->
<h3 class="sectionedit12" id="seven_types_of_java_garbage_collectors">3.2 Seven Types of JAVA Garbage Collectors</h3>
<div class="level3">

<p>
Before Java 11, Oracle hotSpot provides are four types of Java garbage collector:
</p>
<ul>
<li class="level1"><div class="li"> Serial Garbage Collector</div>
</li>
<li class="level1"><div class="li"> Parallel Garbage Collector</div>
</li>
<li class="level1"><div class="li"> <abbr title="Content Management System">CMS</abbr> Garbage Collector</div>
</li>
<li class="level1"><div class="li"> G1 Garbage Collector</div>
</li>
</ul>

<p>
Java 11 has introduced two new garbage collectors:
</p>
<ul>
<li class="level1"><div class="li"> Epsilon Garbage Collector</div>
</li>
<li class="level1"><div class="li"> Z garbage collector</div>
</li>
</ul>

<p>
Java 12 has introduced one new garbage collectors:
</p>
<ul>
<li class="level1"><div class="li"> Shenandoah Garbage Collector</div>
</li>
</ul>

</div>

<h4 id="serial_garbage_collector">3.2.1 Serial Garbage Collector</h4>
<div class="level4">

<p>
This is the simplest GC implementation. All garbage collection events are conducted serially in one thread. It implements the “mark-sweep-compact” strategy. Compaction is executed after each garbage collection. This GC implementation freezes all application threads when it runs.
</p>

<p>
The Serial GC is the garbage collector of choice for most applications that do not have small pause time requirements and run on client-style machines. To enable Serial Garbage Collector, we can use the following argument:
</p>
<pre class="code">java -XX:+UseSerialGC -jar Application.java</pre>

<p>
However, if your application is a multi-threaded server which creates many objects. It&#039;s not a good idea to use this garbage collector.
</p>

</div>

<h4 id="parallel_garbage_collector">3.2.2 Parallel Garbage Collector</h4>
<div class="level4">

<p>
It&#039;s the default GC of the JVM and sometimes called Throughput Collectors. It uses the parallel version of “mark-sweep-compact” approach for <strong>Minor GC</strong> with multiple threads for managing young generation. <strong>Major GC</strong> still happens with a single thread in a serial manner. It also freezes other application threads while performing GC. To enable Serial Garbage Collector, we can use the following argument:
</p>
<pre class="code">java -XX:+UseParallelGC -jar Application.java</pre>

<p>
This garbage collector provide four options for further performance tuning:
</p>
<ul>
<li class="level1"><div class="li"> -XX:ParallelGCThreads=&lt;N&gt;: It defines  the number of parallel threads that need to be spawned to run Minor GC (normally n=number of CPU cores).</div>
</li>
<li class="level1"><div class="li"> -XX:MaxGCPauseMillis=&lt;N&gt;: It defines the maximum pause time goal (gap [in milliseconds] between two GC).</div>
</li>
<li class="level1"><div class="li"> -XX:GCTimeRatio=&lt;N&gt;: It defines the maximum throughput target (measured regarding the time spent doing garbage collection versus the time spent outside of garbage collection)</div>
</li>
<li class="level1"><div class="li"> -Xmx&lt;N&gt;: It defines a maximum heap footprint (the amount of heap memory that a program requires while running)</div>
</li>
</ul>

<p>
There is another version of the parallel garbage collector called <strong>Parallel Old GC</strong>. It uses the parallel version of mark-sweep-compact approach for both Minor and Major GCs with multithreaded. Unlike standard parallel (multithreaded for the minor, single thread for the major.) To enable Old Serial Garbage Collector, we can use the following argument:
</p>
<pre class="code">java -XX:+UseParallelOldGC -jar Application.java</pre>

<p>
The parallel garbage collector(parallel old included) is suited best for those applications that can bear application pauses.
</p>

</div>

<h4 id="concurrent_mark_sweep_collector">3.2.3 Concurrent Mark Sweep Collector</h4>
<div class="level4">

<p>
Concurrent Mark Sweep (<abbr title="Content Management System">CMS</abbr>) garbage collector uses multiple garbage collector threads for garbage collection. It does most of the <strong>Major GC</strong> concurrently within the application threads, but <strong>Minor GC</strong> still follows the usual parallel algorithm without any concurrent progress with application threads. It’s designed for applications that prefer shorter garbage collection pauses, and that can afford to share processor resources with the garbage collector while the application is running.
</p>

<p>
Simply put, applications using this type of GC respond slower (because GC uses more CPU ) on average but do not stop responding to perform garbage collection.  If we can allocate more CPU for better performance, then <strong><abbr title="Content Management System">CMS</abbr> garbage collector</strong> is the preferred choice over the <strong>parallel collector</strong>.
</p>

<p>
A quick point to note here is that since this GC is concurrent, an invocation of explicit garbage collection such as using System.gc() while the concurrent process is working, will result in <strong>Concurrent Mode Failure / Interruption</strong>.
</p>

<p>
If more than 98% of the total time is spent in <abbr title="Content Management System">CMS</abbr> garbage collection and less than 2% of the heap is recovered, then an <strong>OutOfMemoryError</strong> is thrown by the <abbr title="Content Management System">CMS</abbr> collector. If necessary, this feature can be disabled by adding the option <strong>-XX:-UseGCOverheadLimit</strong> to the command line.
</p>

<p>
This collector also has a mode knows as an <strong>incremental mode</strong> which is being <strong>deprecated in Java SE 8</strong> and may be removed in a future major release.
</p>

<p>
To enable the <abbr title="Content Management System">CMS</abbr> Garbage Collector, we can use the following flag:
</p>
<pre class="code">java -XX:+UseParNewGC -jar Application.java

# This option can be used to define the number of parallel threads.
–XX:ParallelCMSThreads=n </pre>

<p>
Note, <abbr title="Content Management System">CMS</abbr> garbage collector holds all the application threads in the following two scenarios only
</p>
<ul>
<li class="level1"><div class="li"> During marking the referenced objects in the old generation space.</div>
</li>
<li class="level1"><div class="li"> Any change in heap memory in parallel with doing the garbage collection</div>
</li>
</ul>

</div>

<h4 id="g1_garbage_collector">3.2.4 G1 Garbage Collector</h4>
<div class="level4">

<p>
G1 (Garbage First) Garbage Collector is designed for applications running on multi-processor machines with large memory space. It&#039;s available since JDK7 Update 4 and in later releases.
</p>

<p>
In general, the G1 collector will replace the <abbr title="Content Management System">CMS</abbr> collector since it&#039;s more performance efficient.
</p>

<p>
The older garbage collectors (serial, parallel, <abbr title="Content Management System">CMS</abbr>) all structure the heap into three sections: young generation, old generation, and permanent generation of a fixed memory size.
<a href="/lib/exe/detail.php?id=employes%3Apengfei.liu%3Ajava%3Ajava_gc&amp;media=employes:pengfei.liu:java:gc_old.png" class="media" title="employes:pengfei.liu:java:gc_old.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=49e020&amp;media=employes:pengfei.liu:java:gc_old.png" class="media" alt="" width="400" /></a>
</p>

<p>
G1 collector partitions the heap into <strong>a set of equal-sized heap regions</strong>, each a contiguous range of virtual memory. When performing garbage collections, G1 shows a concurrent global marking phase (i.e. phase 1 known as Marking) to determine the liveness of objects throughout the heap.
</p>

<p>
<a href="/lib/exe/detail.php?id=employes%3Apengfei.liu%3Ajava%3Ajava_gc&amp;media=employes:pengfei.liu:java:gc_g1.png" class="media" title="employes:pengfei.liu:java:gc_g1.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=72e8ff&amp;media=employes:pengfei.liu:java:gc_g1.png" class="media" alt="" width="400" /></a>
</p>

<p>
After the mark phase is completed, G1 knows which regions are mostly empty. It collects in these areas first, which usually yields a significant amount of free space (i.e. phase 2 known as Sweeping). It is why this method of garbage collection is called Garbage-First.
</p>

<p>
To enable G1 Garbage Collector, we can use the following argument:
</p>
<pre class="code">java -XX:+UseG1GC -jar Application.java</pre>

<p>
For more info, <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html#:~:text=G1%20copies%20objects%20from%20one,pause%20times%20and%20increase%20throughput" class="urlextern" title="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html#:~:text=G1%20copies%20objects%20from%20one,pause%20times%20and%20increase%20throughput" rel="nofollow">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html#:~:text=G1%20copies%20objects%20from%20one,pause%20times%20and%20increase%20throughput</a>.
</p>

</div>

<h4 id="epsilon_garbage_collector">3.2.5 Epsilon Garbage Collector</h4>
<div class="level4">

<p>
Epsilon is a non-operational or passive garbage collector(for testing purpose only). It allocates the memory for the application, but it doesn’t collect the unused objects. When the application exhausts the Java heap, the JVM shuts down. It means Epsilon garbage collector allows, applications to run out of memory and crash.
</p>

<p>
The purpose of this garbage collector is to measure and managing application performance. Because it does not impact the performance of your application at all unlike other GC. There are no GC cycles or read or write barriers. When using the Epsilon GC, the code runs in isolation. Epsilon helps to visualize how garbage collection affects the app’s performance and what are the memory threshold is since it’ll show when it runs out. 
</p>

<p>
To enable Epsilon Garbage Collector, we can use the following argument
</p>
<pre class="code">java -XX:+UseEpsilonGC -jar Application.java

# options for dumping heap memory when the application is crashing due to out of memory 
-XX:HeapDumpOnOutOfMemoryError</pre>

<p>
If we need to squeeze every bit of performance out of our application, Epsilon might be your best option for a GC. But we need to have a complete understanding of how our code uses memory. If it creates almost no garbage or you know exactly how much memory it uses for the period it runs in, Epsilon is a viable option.
</p>

<p>
Another use case is testing your application memory consumption. For example, if we think we only need one gigabyte of memory for our application, we can run it with -Xmx1g and see the behavior. If that memory allocation is not sufficient, rerun it with a heap dump to know why we need more memory.
</p>

</div>

<h4 id="z_garbage_collector">3.2.6 Z garbage collector</h4>
<div class="level4">

<p>
ZGC performs all expensive work concurrently, without stopping the execution of application threads for more than 10ms, which makes it suitable for applications that require low latency and/or use a very large heap. According to the Oracle documentation, it can handle multi-terabyte heaps. Oracle introduced ZGC in Java 11. The Z garbage collector performs its cycles in its threads. It pauses the application for an average of 1 ms. The G1 and Parallel collectors average roughly 200 ms.
</p>

<p>
In Java 12, Oracle added performance fixes and class unloading even though Z is still in experimental status. It’s only available on 64-bit Linux. But, ZGC takes advantage of 64-bit pointers with a technique called pointer coloring. Colored pointers store extra information about objects on the heap. This is one of the reasons it’s limited to the 64-bit JVM. This article has been explained this scenario deeply (<a href="https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/" class="urlextern" title="https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/" rel="nofollow">https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/</a>)
</p>

<p>
ZGC does its marking in three phases:
</p>
<ol>
<li class="level1"><div class="li"> Short stop-the-world phase — It examines the GC roots, local variables that point to the rest of the heap. The total number of these roots is usually minimal and doesn’t scale with the size of the load, so ZGC’s pauses are very short and don’t increase as your heap grows.</div>
</li>
<li class="level1"><div class="li"> Concurrent phase — It walks the object graph and examines the colored pointers, marking accessible objects. The load barrier prevents contention between the GC phase and any application’s activity.</div>
</li>
<li class="level1"><div class="li"> Relocation phase — It moves live objects to free up large sections of the heap to make allocations faster. When the relocation phase begins, ZGC divides the heap into pages and works on one page at a time. Once ZGC finishes moving any roots, the rest of the relocation happens in a concurrent phase.</div>
</li>
</ol>

<p>
ZGC will try to set the number of threads itself, and it’s usually right. But if ZGC has too many threads, it will starve your application. If it doesn’t have enough, you’ll create garbage faster than the GC can collect it. ZGC’s phases illustrate how it manages large heaps without impacting performance as application memory grows.
</p>

<p>
To enable Z Garbage Collector, we can use the following argument:
</p>
<pre class="code">java -XX:+UseZGC -jar Application.java</pre>

</div>

<h4 id="shenandoah">3.2.7 Shenandoah</h4>
<div class="level4">

<p>
Shenandoah is an ultra-low pause time garbage collector that reduces GC pause times by performing more garbage collection work concurrently with the running Java program. <strong><abbr title="Content Management System">CMS</abbr> and G1 both perform concurrent marking of live objects. Shenandoah adds concurrent compaction.</strong>
</p>

<p>
Shenandoah uses memory regions to manage which objects are no longer in use and which are live and ready for compression. Shenandoah also adds a forwarding pointer to every heap object and uses it to control access to the object. Shenandoah’s design trades concurrent CPU cycles and space for pause time improvements. The forwarding pointer makes it easy to move objects, but the aggressive moves mean Shenandoah uses more memory and requires more parallel work than other GCs. But it does the extra work with very <strong>brief stop-the-world pauses.</strong>
</p>

<p>
Shenandoah processes the heap in many small phases, most of which are concurrent with the application. This design makes it possible for the GC to manage a large heap efficiently.
</p>
<ol>
<li class="level1"><div class="li"> <strong>First stop-the-world pause in the cycle. It prepares the heap for concurrent marking and scans the root set.</strong> LikeZGC, the length of this pause corresponds to the size of the root set, not the heap.</div>
</li>
<li class="level1"><div class="li"> Next, a concurrent phase <strong>walks the heap and identifies reachable and unreachable objects.</strong></div>
</li>
<li class="level1"><div class="li"> The third finishes the <strong>process of marking by draining pending heap updates and re-scanning the root set.</strong> This phase triggers the second stop-the-world pause in the cycle. The number of pending updates and the size of the root set determine how long the pause is.</div>
</li>
<li class="level1"><div class="li"> Then, another concurrent phase <strong>copies the objects out of the regions identified in the final mark phase.</strong> This process sets Shenandoah apart from other GCs since it aggressively compacts the heap in parallel with application threads.</div>
</li>
<li class="level1"><div class="li"> The next phase triggers the third (and shortest) pause in the cycle. It <strong>ensures that all GC threads have finished evacuation.</strong></div>
</li>
<li class="level1"><div class="li"> When it finishes, <strong>a concurrent phase walks the heap and updates references to objects moved earlier in the cycle.</strong></div>
</li>
<li class="level1"><div class="li"> The last stop-the-world pause in the <strong>cycle finishes updating the references by updating the root set.</strong> At the same time, it recycles the evacuated regions.</div>
</li>
<li class="level1"><div class="li"> Finally, the <strong>last phase reclaims the evacuated regions</strong>, which now have no references in them.</div>
</li>
</ol>

<p>
We can configure Shenandoah with one of three heuristics. They govern when the GC starts its cycles and how it selects regions for evacuation.
</p>
<ol>
<li class="level1"><div class="li"> <strong>Adaptive</strong>: Observes GC cycles and starts the next cycle so it completes before the application exhausts the heap. This heuristic is the default mode.</div>
</li>
<li class="level1"><div class="li"> <strong>Static</strong>: Starts a GC cycle based on heap occupancy and allocation pressure.</div>
</li>
<li class="level1"><div class="li"> <strong>Compact</strong>: Runs GC cycles continuously. Shenandoah starts a new cycle as soon as the previous finishes or based on the amount of heap-allocated since the last cycle. This heuristic incurs throughput overhead but provides the best space reclamation.</div>
</li>
</ol>

<p>
Shenandoah needs to collect heap faster than the application it’s serving allocates it. If the allocation pressure is too high and there’s not enough space for new allocations, there will be a failure. Shenandoah has configurable mechanisms for this situation.
</p>
<ul>
<li class="level1"><div class="li"> <strong>Pacing</strong>: If Shenandoah starts to fall behind the rate of allocation, it will stall allocation threads to catch up. The stalls are usually enough for mild allocation spikes. Shenandoah introduces delays of 10ms or less. If pacing fails, Shenandoah will move to the next step: degenerated GC.</div>
</li>
<li class="level1"><div class="li"> <strong>Degenerated GC</strong>: If an allocation failure occurs, Shenandoah starts a stop-the-world phase. It uses the phase to complete the current GC cycle. Since a stop-the-world doesn’t contend with the application for resources, the cycle should finish quickly and clear the allocation shortfall. Often, a degenerated cycle happens after most of the cycle’s work is already completed, so the stop-the-world is brief. The GC log will report it as a full pause, though.</div>
</li>
<li class="level1"><div class="li"> <strong>Full GC</strong>: If both pacing and a degenerated GC fail, Shenandoah falls back to a full GC cycle. This final GC guarantees the application won’t fail with an out-of-memory error unless there’s no heap left.</div>
</li>
</ul>

<p>
Shenandoah offers the same advantages as ZGC with large heaps but more tuning options. Depending on the nature of your application, the different heuristics may be a good fit. Its pause times might not be as brief as ZGC’s, but they’re more predictable.
</p>

<p>
To enable the Shenandoah Garbage Collector, we can use the following argument:
</p>
<pre class="code">java -XX:+UseShenanodoahC -jar Application.java</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;3.2 Seven Types of JAVA Garbage Collectors&quot;,&quot;hid&quot;:&quot;seven_types_of_java_garbage_collectors&quot;,&quot;codeblockOffset&quot;:5,&quot;secid&quot;:12,&quot;range&quot;:&quot;12735-27707&quot;} -->
<h2 class="sectionedit13" id="memory_leak">4. Memory leak</h2>
<div class="level2">

<p>
In computer science, a <strong>memory leak</strong> is a type of resource leak that occurs when a computer program incorrectly manages memory allocations in such a way that memory which is no longer needed is not released. A memory leak may also happen when an object is stored in memory but cannot be accessed by the running code. A memory leak has symptoms similar to a number of other problems and generally can only be diagnosed by a programmer with access to the programs&#039; source code.
</p>

<p>
A <strong>space leak</strong> occurs when a computer program uses more memory than necessary. In contrast to memory leaks, where the leaked memory is never released, the memory consumed by a space leak is released, but later than expected. 
</p>

<p>
The major purpose of learning how GC works is to prevent memory leaks. By its design, Java garbage collection is dedicated to track live objects, remove unused, and free up the Heap for future objects, which is the most important memory management mechanism in the JVM. However, programmers can screw up this automatic process by leaving a reference to an unused object, making it still reachable, hence not getting eligible for GC. <strong>Accumulation of such unused-but-still-referenced objects consumes the Heap memory inefficiently and this situation is called a memory leak.</strong>
</p>

<p>
Detecting this type of logical memory leaks in a large-scale application can be the worst nightmare for a developer. There are sophisticated analysis tools and methods today, but they only can highlight suspicious objects. The detection and removal of memory leaks have been always an exhaustive process.<strong> As a result, it is highly advised for developers to be very conscious when you play with object references in your code.</strong>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;4. Memory leak&quot;,&quot;hid&quot;:&quot;memory_leak&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:13,&quot;range&quot;:&quot;27708-29452&quot;} -->
<h2 class="sectionedit14" id="the_life_cycle_of_an_object_in_java_before_and_after_gc">5. the Life Cycle of an Object in Java (before and after GC)</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;5. the Life Cycle of an Object in Java (before and after GC)&quot;,&quot;hid&quot;:&quot;the_life_cycle_of_an_object_in_java_before_and_after_gc&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:14,&quot;range&quot;:&quot;29453-29527&quot;} -->
<h3 class="sectionedit15" id="class_loading">5.1 Class loading</h3>
<div class="level3">

<p>
Before an object can be created from a class, the class must be loaded. To do that, the Java runtime locates the class on disk (in a .class file) and reads it into memory.
</p>

<p>
Then Java looks for any static initializers that initialize static fields — fields that don’t belong to any particular instance of the class, but belong to the class itself and are shared by all objects created from the class.
</p>

<p>
A class is loaded the first time you create an object from the class or the first time you access a static field or method of the class. When you run the main method of a class, for example, the class is initialized because the main method is static.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;5.1 Class loading&quot;,&quot;hid&quot;:&quot;class_loading&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:15,&quot;range&quot;:&quot;29528-30213&quot;} -->
<h3 class="sectionedit16" id="object_creation">5.2 Object creation</h3>
<div class="level3">

<p>
An object is created from a class when you use the new keyword. To initialize the class, Java allocates memory for the object and sets up a reference to the object so that the Java runtime can keep track of it.
</p>

<p>
Then Java calls the <strong>constructor</strong> of the class, which is like a method but is called only once when the object is created. The constructor is responsible for doing any processing required to initialize the object — initializing variables, opening files or databases, and so on.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;5.2 Object creation&quot;,&quot;hid&quot;:&quot;object_creation&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:16,&quot;range&quot;:&quot;30214-30739&quot;} -->
<h3 class="sectionedit17" id="object_running">5.3 Object running</h3>
<div class="level3">

<p>
The object lives its life, providing access to its public methods and fields to whoever wants and needs them.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;5.3 Object running&quot;,&quot;hid&quot;:&quot;object_running&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:17,&quot;range&quot;:&quot;30740-30880&quot;} -->
<h3 class="sectionedit18" id="object_deletion">5.4 Object deletion</h3>
<div class="level3">

<p>
When an object does not have any external reference, the object is marked by GC and removed from memory after the sweep phase and JVM drops its internal reference to it. 
</p>

<p>
Before destroying an object, Garbage Collector calls <strong>finalize()</strong> method at most one time on that object (<strong>finalize() method never gets invoked more than once for any given object</strong>). The default finalize() method has empty implementation. Once finalize() method completes, Garbage Collector destroys that object.
</p>

<p>
By overriding the finalize() method, we can perform our cleanup activities like closing a database connection or verify the end of that object as I have written below.
</p>
<pre class="code">class Person {   
    // to store person (object) name
    String name;
     
    public Person(String name) {
        this.name = name;
    }
     
    @Override
    /* Overriding finalize method to check which object is garbage collected */
    protected void finalize() throws Throwable {
        // will print name of person (object)
        System.out.println(&quot;Person object - &quot; + this.name + &quot; -&gt; successfully garbage collected&quot;);
    }
}</pre>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;5.4 Object deletion&quot;,&quot;hid&quot;:&quot;object_deletion&quot;,&quot;codeblockOffset&quot;:13,&quot;secid&quot;:18,&quot;range&quot;:&quot;30881-32030&quot;} -->
<h2 class="sectionedit19" id="other_jvm_memory_tunning_options">6. Other JVM memory tunning options</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;6. Other JVM memory tunning options&quot;,&quot;hid&quot;:&quot;other_jvm_memory_tunning_options&quot;,&quot;codeblockOffset&quot;:14,&quot;secid&quot;:19,&quot;range&quot;:&quot;32031-32079&quot;} -->
<h3 class="sectionedit20" id="removing_duplicating_string_in_heap_memory">6.1 Removing duplicating string in heap memory</h3>
<div class="level3">

<p>
Java 8u20 has introduced one more JVM parameter for reducing the unnecessary use of memory by creating too many instances of same String. This optimizes the heap memory by removing duplicate String values to a global single char[] array.
</p>

<p>
This parameter can be enabled by adding <strong>-XX:+UseStringDeduplication</strong> as JVM parameter.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;6.1 Removing duplicating string in heap memory&quot;,&quot;hid&quot;:&quot;removing_duplicating_string_in_heap_memory&quot;,&quot;codeblockOffset&quot;:14,&quot;secid&quot;:20,&quot;range&quot;:&quot;32080-&quot;} -->