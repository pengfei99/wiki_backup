a:101:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"What is a (micro)service?";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:502:"The microservice architecture (sometimes abbreviated to microservices) is an architectural style that structures an application as a collection of services that are organized around business capabilities. It enables the continuous delivery/deployment of large, complex applications. The microservice architecture has several other benefits including better scalability and fault tolerance. It also makes it easier for an organization to experiment with new technologies and evolve its technology stack.";}i:2;i:42;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:544;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:544;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:345:"The most critical architectural decision that you must make when using microservices is to identify and design the services and determine how they collaborate. In comparison, technology-related issues, such as Serverless, Docker, and Kubernetes, pale into insignificance. This is the first of several posts that explores the nature of a service.";}i:2;i:546;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:891;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:893;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:32:"Key characteristics of a service";i:1;i:2;i:2;i:893;}i:2;i:893;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:893;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:893;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:"A service has several key characteristics:";}i:2;i:939;}i:14;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:982;}i:15;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:982;}i:16;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:982;}i:17;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:982;}i:18;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:" Highly maintainable and testable - enables rapid and frequent development and deployment";}i:2;i:986;}i:19;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1075;}i:20;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1075;}i:21;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1075;}i:22;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1075;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:205:" Loosely coupled with other services - enables a team to work independently the majority of time on their service(s) without being impacted by changes to other services and without affecting other services";}i:2;i:1079;}i:24;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1284;}i:25;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1284;}i:26;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1284;}i:27;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1284;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:112:" Independently deployable - enables a team to deploy their service without having to coordinate with other teams";}i:2;i:1288;}i:29;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1400;}i:30;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1400;}i:31;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1400;}i:32;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1400;}i:33;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:136:" Capable of being developed by a small team - essential for high productivity by avoiding the high communication overhead of large teams";}i:2;i:1404;}i:34;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1540;}i:35;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1540;}i:36;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:1540;}i:37;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1542;}i:38;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"The structure of a service";i:1;i:2;i:2;i:1542;}i:2;i:1542;}i:39;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1542;}i:40;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1542;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:222:"The following diagram shows the structure of a service. It has a hexagonal architecture. The core of the service is its business logic, which is surrounded by adapters that communicate with other services and applications.";}i:2;i:1581;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1803;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1803;}i:44;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:72:":employes:pengfei.liu:system_architecture:microservice:service_archi.png";i:1;s:0:"";i:2;N;i:3;s:3:"400";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:1805;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1886;}i:46;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1889;}i:47;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"A service has an API";i:1;i:2;i:2;i:1889;}i:2;i:1889;}i:48;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1889;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1889;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"From the perspective of its consumers, the only thing that matters about a service is its ";}i:2;i:1923;}i:51;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"API";}i:2;i:2013;}i:52;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:". A service ";}i:2;i:2016;}i:53;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"API";}i:2;i:2028;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:" consists of operations and published events.";}i:2;i:2031;}i:55;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2076;}i:56;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2078;}i:57;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:10:"Operations";i:1;i:3;i:2;i:2078;}i:2;i:2078;}i:58;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2078;}i:59;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2078;}i:60;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:181:"There are two types of operations: commands and queries. A command is an operation that mutates data. A query is a command that retrieves data. For example, in the FTGO application(";}i:2;i:2100;}i:61;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:59:"https://github.com/microservices-patterns/ftgo-application/";i:1;N;}i:2;i:2281;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:155:"), the Order Service, implements commands, such as createOrder(), reviseOrder() and cancelOrder(), and queries, such as findOrder() and findOrderHistory().";}i:2;i:2340;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2495;}i:64;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2495;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:302:"A service’s operations are invoked using some combination of synchronous protocols, such as REST or gRPC, and asynchronous messaging. Synchronous protocols, especially REST, are particularly useful when implementing APIs for external clients, such as mobile applications and Single Page applications.";}i:2;i:2497;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2799;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2799;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:334:"However, asynchronous protocols are typically needed when implementing sagas, which maintain data consistency between services. For example, the book store Order Service’s createOrder() operation is implemented by the POST /orders REST endpoint and initiates the Create Order Saga, which is implemented using asynchronous messaging.";}i:2;i:2801;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3135;}i:70;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3137;}i:71;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:6:"Events";i:1;i:3;i:2;i:3137;}i:2;i:3137;}i:72;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3137;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3137;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:340:"A service often publishes events. An event is typically DDD domain events, which are emitted by an aggregate when it’s created, updated or deleted. A service publishes events to a message channel implemented by a message broker. The Eventuate Tram framework, for example, supports publishing events to Apache Kafka, ActiveMQ and RabbitMQ.";}i:2;i:3155;}i:75;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3495;}i:76;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3497;}i:77;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"Business logic";i:1;i:3;i:2;i:3497;}i:2;i:3497;}i:78;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3497;}i:79;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3497;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:255:"The heart of the service and the reason for its existence. It implements the API’s operations and publishes events. The business logic invokes the operations of other services and subscribes to their events. It persists data in the service’s database.";}i:2;i:3523;}i:81;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3778;}i:82;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3780;}i:83;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:47:"A service might collaborate with other services";i:1;i:3;i:2;i:3780;}i:2;i:3780;}i:84;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3780;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3780;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:144:"When services collaborate, it’s through APIs rather than via the database. A service might invoke the operations of another service. The FTGO(";}i:2;i:3839;}i:87;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:59:"https://github.com/microservices-patterns/ftgo-application/";i:1;N;}i:2;i:3983;}i:88;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:82:") Order Service, for example, asynchronously invokes the Kitchen Service services.";}i:2;i:4042;}i:89;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4124;}i:90;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4124;}i:91;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:162:"A service can also subscribe to the events published by another service. The Order Service, for example, subscribes to events published by the Restaurant Service.";}i:2;i:4126;}i:92;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4288;}i:93;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4290;}i:94;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"A service's database is private";i:1;i:3;i:2;i:4290;}i:2;i:4290;}i:95;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4290;}i:96;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4290;}i:97;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:405:"A service usually has a database, which stores its data and sometimes data replicated from other services. For example, the FTGO Order Service’s database stores Orders as well as Restaurants, which are replicated from the Restaurant Service. In order to ensure loose coupling, it’s generally a bad idea for services to share database tables. Instead, services must only communicate through their APIs.";}i:2;i:4332;}i:98;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4737;}i:99;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4739;}i:100;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4739;}}