a:743:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"Understanding JVM Architecture";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:47;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"Java Environments";i:1;i:2;i:2;i:47;}i:2;i:47;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:47;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:47;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:421:"For almost any programming language, you need a specific environment which comprises of all the necessary components, application programming interfaces, and libraries in order to develop, compile, debug, and execute its programs. Java has 2 such environments and everyone working with Java has to start their work after setting up one of these environments on their local development or production environment platforms.";}i:2;i:78;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:500;}i:9;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:500;}i:10;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:500;}i:11;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:500;}i:12;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:184:" JRE (Java Runtime Environment): the minimum environment needed for running a Java application (no support for developing). It includes JVM (Java Virtual Machine) and deployment tools.";}i:2;i:504;}i:13;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:688;}i:14;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:688;}i:15;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:688;}i:16;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:688;}i:17;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:162:" JDK (Java Development Kit): the complete development environment used for developing and executing Java applications. It includes both JRE and development tools.";}i:2;i:692;}i:18;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:854;}i:19;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:854;}i:20;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:854;}i:21;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:854;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"In another word, JRE is meant for users, while JDK is meant for programmers.";}i:2;i:856;}i:23;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:932;}i:24;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:934;}i:25;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"How Java Works";i:1;i:3;i:2;i:934;}i:2;i:934;}i:26;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:934;}i:27;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:959;}i:28;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:959;}i:29;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:959;}i:30;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:157:" Java source codes are compiled into an intermediate state called bytecode(i.e. a .class file) using the Java Compiler (javac) which comes inbuilt with JDK. ";}i:2;i:963;}i:31;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1120;}i:32;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1120;}i:33;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1120;}i:34;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1120;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:200:" This bytecode is in hexadecimal format with opcode-operand lines and JVM can interpret these instructions (without further recompilations) into native machine language which can be understood by the ";}i:2;i:1124;}i:36;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:1324;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:" and underlying hardware platform. ";}i:2;i:1326;}i:38;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1361;}i:39;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1361;}i:40;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1361;}i:41;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1361;}i:42;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:128:" Therefore, bytecode acts as a platform-independent intermediary state which is portable among any JVM regardless of underlying ";}i:2;i:1365;}i:43;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:1493;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:116:" and hardware architecture. However, since JVMs are developed to run and communicate with the underlying hardware & ";}i:2;i:1495;}i:45;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:1611;}i:46;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:" structure, we need to select the appropriate JVM version for our ";}i:2;i:1613;}i:47;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:1679;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" version (Windows, Linux, Mac) and processor architecture (x86, x64).";}i:2;i:1681;}i:49;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1750;}i:50;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1750;}i:51;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:1750;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1750;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"So the ";}i:2;i:1752;}i:54;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:1759;}i:55;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"JVM(Java virtual machine) is the most important part of java";}i:2;i:1761;}i:56;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:1821;}i:57;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:", which performs many run-time activities like JIT (Just-in-time) compilation & GC (Garbage Collection) during the program execution.";}i:2;i:1823;}i:58;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1956;}i:59;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1956;}i:60;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:1958;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:"The JVM is a model of a whole computer, that resides on the RAM of a physical PC";}i:2;i:1960;}i:62;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:2040;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:2042;}i:64;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2043;}i:65;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2045;}i:66;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"JVM Architecture";i:1;i:1;i:2;i:2045;}i:2;i:2045;}i:67;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:2045;}i:68;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2045;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:223:"JVM is only a specification, and its implementation is different from vendor to vendor(e.g. Oracle, OpenJDK, etc.). In this article, we only address the commonly-accepted architecture of JVM as defined in the specification.";}i:2;i:2077;}i:70;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2300;}i:71;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2300;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:"A JVM contains three major components:";}i:2;i:2302;}i:73;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2340;}i:74;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:2340;}i:75;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2340;}i:76;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2340;}i:77;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:157:" Class loader subsystem: It loads, links, and initializes the class file (.class) when it refers to a class for the first time at runtime (not compile time).";}i:2;i:2344;}i:78;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2501;}i:79;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2501;}i:80;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2501;}i:81;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2501;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:" Runtime Data Areas: They are the memory areas assigned when the JVM program runs on the ";}i:2;i:2505;}i:83;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:2594;}i:84;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:".  ";}i:2;i:2596;}i:85;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2599;}i:86;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2599;}i:87;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2599;}i:88;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2599;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:138:" Execution Engine: It executes the instructions in the bytecode line-by-line by reading the data assigned to the above runtime data areas.";}i:2;i:2603;}i:90;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2741;}i:91;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2741;}i:92;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:2741;}i:93;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2741;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"See the below figure.";}i:2;i:2743;}i:95;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2764;}i:96;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2764;}i:97;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:52:":employes:pengfei.liu:java:full_jvm_architecture.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:2766;}i:98;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2827;}i:99;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2830;}i:100;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"1. Class Loader Subsystem";i:1;i:2;i:2;i:2830;}i:2;i:2830;}i:101;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2830;}i:102;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2830;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:316:"During the execution of an application in JVM, JVM uses the Class loader subsystem to bring the class files on to the RAM. This is called Java’s dynamic class loading functionality. It loads, links, and initializes the class file (.class) when it refers to a class for the first time at runtime (not compile time).";}i:2;i:2869;}i:104;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3185;}i:105;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3185;}i:106;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"Class-loading has three main steps:";}i:2;i:3187;}i:107;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3222;}i:108;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:3222;}i:109;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3222;}i:110;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3222;}i:111;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" Loading";}i:2;i:3226;}i:112;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3234;}i:113;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3234;}i:114;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3234;}i:115;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3234;}i:116;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" Linking";}i:2;i:3238;}i:117;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3246;}i:118;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3246;}i:119;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3246;}i:120;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3246;}i:121;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Initializing";}i:2;i:3250;}i:122;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3263;}i:123;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3263;}i:124;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:3263;}i:125;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3266;}i:126;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"1.1 Loading";i:1;i:4;i:2;i:3266;}i:2;i:3266;}i:127;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:3266;}i:128;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3266;}i:129;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:374:"In the Loading stage, class-loader loads compiled classes (.class files or bytecode) into memory. Usually, the class loading process starts from loading the main class (i.e. a class with static main() method declaration). All the subsequent class loading attempts are done according to the class references in the already-running classes as mentioned in the following cases:";}i:2;i:3287;}i:130;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3661;}i:131;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:3661;}i:132;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3661;}i:133;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3661;}i:134;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:" When bytecode make a static reference to a class (e.g. System.out, calls the static field ";}i:2;i:3665;}i:135;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3756;}i:136;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"out";}i:2;i:3757;}i:137;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3760;}i:138;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" of class ";}i:2;i:3761;}i:139;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3771;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"System";}i:2;i:3772;}i:141;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3778;}i:142;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:")";}i:2;i:3779;}i:143;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3780;}i:144;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3780;}i:145;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3780;}i:146;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3780;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:70:" When bytecode create a class object (e.g. Person person = new Person(";}i:2;i:3784;}i:148;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3854;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"John";}i:2;i:3855;}i:150;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3859;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"))";}i:2;i:3860;}i:152;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3862;}i:153;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3862;}i:154;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:3862;}i:155;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3862;}i:156;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"There are 3 types of class loaders:";}i:2;i:3864;}i:157;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3899;}i:158;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:3899;}i:159;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3899;}i:160;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3899;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:3903;}i:162;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3904;}i:163;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"Bootstrap class loader";}i:2;i:3906;}i:164;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3928;}i:165;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:": It loads standard JDK classes from rt.jar such as core Java ";}i:2;i:3930;}i:166;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"API";}i:2;i:3992;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:209:" classes present in the bootstrap path — $JAVA_HOME/jre/lib directory (e.g. java.lang.* package classes). It is implemented in native languages like C/C++ and acts as the parent of all class loaders in Java.";}i:2;i:3995;}i:168;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4204;}i:169;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4204;}i:170;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4204;}i:171;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4204;}i:172;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:4208;}i:173;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4209;}i:174;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"Extension class loader";}i:2;i:4211;}i:175;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4233;}i:176;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:369:": It delegates class loading requests to its parent, Bootstrap and if unsuccessful, loads classes from the extensions directories (e.g. security extension functions) in extension path — $JAVA_HOME/jre/lib/ext or any other directory specified by the java.ext.dirs system property. This class loader is implemented in Java by the sun.misc.Launcher$ExtClassLoader class.";}i:2;i:4235;}i:177;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4604;}i:178;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4604;}i:179;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4604;}i:180;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4604;}i:181;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:4608;}i:182;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4609;}i:183;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"Application class loader";}i:2;i:4611;}i:184;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4635;}i:185;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:297:": It loads application-specific classes from system class-path, that can be set while using java -cp or -classpath command-line options. It internally uses Environment Variable which mapped to java.class.path. This class loader is implemented in Java by the sun.misc.Launcher$AppClassLoader class.";}i:2;i:4637;}i:186;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4934;}i:187;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4934;}i:188;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:4934;}i:189;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4934;}i:190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:"All class loader follows the following four principals:";}i:2;i:4936;}i:191;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4991;}i:192;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:4991;}i:193;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4991;}i:194;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4991;}i:195;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:4995;}i:196;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4996;}i:197;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"Visibility Principle";}i:2;i:4998;}i:198;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:5018;}i:199;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:170:": It states that the Child class loader can see the class loaded by parent class loader, but a Parent class loader cannot find the class loaded by the child class loader.";}i:2;i:5020;}i:200;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5190;}i:201;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5190;}i:202;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5190;}i:203;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5190;}i:204;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:5194;}i:205;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:5195;}i:206;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"Uniqueness Principle";}i:2;i:5197;}i:207;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:5217;}i:208;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:153:": It states that a class loaded by a parent should not be loaded by any child class loader again and ensure that duplicate class loading does not occur. ";}i:2;i:5219;}i:209;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5372;}i:210;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5372;}i:211;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5372;}i:212;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5372;}i:213;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:5376;}i:214;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:5377;}i:215;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"Delegation Hierarchy Principle";}i:2;i:5379;}i:216;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:5409;}i:217;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:189:": In order to satisfy the above two principles, JVM follows a hierarchy of delegation to choose the class loader for each class loading request. Here, starting from the lowest child level, ";}i:2;i:5411;}i:218;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5600;}i:219;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"Application Class Loader";}i:2;i:5601;}i:220;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5625;}i:221;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:" delegates the received class loading request to ";}i:2;i:5626;}i:222;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5675;}i:223;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"Extension Class Loader";}i:2;i:5676;}i:224;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5698;}i:225;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" and then ";}i:2;i:5699;}i:226;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5709;}i:227;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"Extension Class Loader";}i:2;i:5710;}i:228;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5732;}i:229;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" delegates the request to ";}i:2;i:5733;}i:230;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5759;}i:231;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"Bootstrap Class Loader";}i:2;i:5760;}i:232;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5782;}i:233;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:468:". If the requested class found in Bootstrap path, the class is loaded. Otherwise, the request again transfers back to Extension Class Loader level to find the class from Extension path or custom-specified path. If it also fails, the request comes back to Application Class Loader to find the class from System class path and if Application Class Loader also fails to load the requested class, then we get the run time exception (i.e. java.lang.ClassNotFoundException).";}i:2;i:5783;}i:234;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:6251;}i:235;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:6251;}i:236;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:6251;}i:237;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:6251;}i:238;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6255;}i:239;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:6256;}i:240;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"No Unloading Principle";}i:2;i:6258;}i:241;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:6280;}i:242;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:": a class loader cannot unload a loaded class. Instead of unloading, the current class loader can be deleted, and a new class loader can be created.";}i:2;i:6282;}i:243;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:6430;}i:244;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:6430;}i:245;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:6430;}i:246;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6430;}i:247;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:"The following figure shows the java class loader delegation hierarchy principle.";}i:2;i:6432;}i:248;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6512;}i:249;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6512;}i:250;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:64:":employes:pengfei.liu:java:class_loader_delegation_hierarchy.png";i:1;s:0:"";i:2;N;i:3;s:3:"400";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:6514;}i:251;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6587;}i:252;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6587;}i:253;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"Two important notes of class loader:";}i:2;i:6590;}i:254;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6626;}i:255;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:6626;}i:256;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:6626;}i:257;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:6626;}i:258;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:" A programmer can directly create a ";}i:2;i:6630;}i:259;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:6666;}i:260;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"User-defined Class Loader";}i:2;i:6668;}i:261;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:6693;}i:262;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:277:" on the code itself without changing the above three class loaders. This guarantees the independence of applications through class loader delegation model. This approach is used in web application servers like Tomcat to make web apps and enterprise solutions run independently.";}i:2;i:6695;}i:263;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:6972;}i:264;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:6972;}i:265;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:6972;}i:266;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:6972;}i:267;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:439:" Each class loader has its namespace that stores the loaded classes. When a class loader loads a class, it searches the class based on FQCN (Fully Qualified Class Name) stored in the namespace to check whether or not the class has been already loaded. Even if the class has an identical FQCN but a different namespace, it is regarded as a different class. A different namespace means that the class has been loaded by another Class Loader.";}i:2;i:6976;}i:268;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7415;}i:269;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7415;}i:270;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:7415;}i:271;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7417;}i:272;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"1.2 Linking";i:1;i:4;i:2;i:7417;}i:2;i:7417;}i:273;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:7417;}i:274;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7417;}i:275;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:191:"Linking involves in verifying and preparing a loaded class or interface, its direct super-classes and super-interfaces, and its element type as necessary while following the below properties:";}i:2;i:7438;}i:276;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7629;}i:277;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:7629;}i:278;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7629;}i:279;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7629;}i:280;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:" A class or interface must be completely loaded before it is linked.";}i:2;i:7633;}i:281;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7701;}i:282;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7701;}i:283;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7701;}i:284;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7701;}i:285;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:" A class or interface must be completely verified and prepared before it initialized (in the next step).";}i:2;i:7705;}i:286;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7809;}i:287;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7809;}i:288;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7809;}i:289;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7809;}i:290;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:222:" If an error occurs during linking, it is thrown at a point in the program where some action will be taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.";}i:2;i:7813;}i:291;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8035;}i:292;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8035;}i:293;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:8035;}i:294;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8035;}i:295;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:"Linking has three key stages as below:";}i:2;i:8037;}i:296;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8076;}i:297;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8076;}i:298;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"Verification";i:1;i:5;i:2;i:8076;}i:2;i:8076;}i:299;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:8076;}i:300;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8076;}i:301;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:609:"It ensures the correctness of .class file (is the code properly written according to Java Language Specification? is it generated by a valid compiler according to JVM specifications?). This is the most complicated test process of the class load processes. And it takes the longest time. Even though linking slows down the class loading process, it avoids the need to perform these checks multiple times when executing bytecode, hence makes the overall execution efficient and effective. If verification fails, it throws runtime errors (java.lang.VerifyError). For instance, the following checks are performed.";}i:2;i:8095;}i:302;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8704;}i:303;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:8704;}i:304;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8704;}i:305;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8704;}i:306;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:" consistent and correctly formatted symbol table";}i:2;i:8708;}i:307;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8756;}i:308;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8756;}i:309;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8756;}i:310;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8756;}i:311;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:" final methods/classes not overridden";}i:2;i:8760;}i:312;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8797;}i:313;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8797;}i:314;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8797;}i:315;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8797;}i:316;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:" methods respect access control keywords";}i:2;i:8801;}i:317;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8841;}i:318;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8841;}i:319;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8841;}i:320;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8841;}i:321;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:" methods have the correct number and type of parameters";}i:2;i:8845;}i:322;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8900;}i:323;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8900;}i:324;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8900;}i:325;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8900;}i:326;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:" bytecode doesn’t manipulate stack incorrectly";}i:2;i:8904;}i:327;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:8952;}i:328;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:8952;}i:329;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:8952;}i:330;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:8952;}i:331;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:44:" variables are initialized before being read";}i:2;i:8956;}i:332;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9000;}i:333;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9000;}i:334;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9000;}i:335;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9000;}i:336;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:" variables are a value of the correct type";}i:2;i:9004;}i:337;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9046;}i:338;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9046;}i:339;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:9046;}i:340;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9048;}i:341;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"Preparation";i:1;i:5;i:2;i:9048;}i:2;i:9048;}i:342;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:9048;}i:343;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9048;}i:344;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:544:"It allocates memory for static storage and any data structures used by the JVM such as method tables. Static fields are created and initialized to their default values, however, no initializers or code is executed at this stage as that happens as part of initialization. For example, if we have private static boolean flag=true; in a class. This 
stage will only allocate memory for this field and assign a default value(e.g. false for primitive boolean, null for object Boolean). The value true will be assigned in the next stage initializing.";}i:2;i:9066;}i:345;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9610;}i:346;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9613;}i:347;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:10:"Resolution";i:1;i:5;i:2;i:9613;}i:2;i:9613;}i:348;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:9613;}i:349;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9613;}i:350;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:147:"It replaces symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.";}i:2;i:9630;}i:351;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9777;}i:352;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9779;}i:353;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"1.3 Initializing";i:1;i:4;i:2;i:9779;}i:2;i:9779;}i:354;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:9779;}i:355;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9779;}i:356;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:384:"In this stage, the initialization logic of each loaded class or interface will be executed (e.g. calling the constructor of a class). Since JVM is multi-threaded, initialization of a class or interface should happen very carefully with proper synchronization to avoid some other thread from trying to initialize the same class or interface at the same time (i.e. make it thread-safe).";}i:2;i:9805;}i:357;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10189;}i:358;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10189;}i:359;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:286:"This is the final phase of class loading where all the static variables are assigned with their original values defined in the code and the static block will be executed (if any). This is executed line by line from top to bottom in a class and from parent to child in a class hierarchy.";}i:2;i:10191;}i:360;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10477;}i:361;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10479;}i:362;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"2. Runtime data areas";i:1;i:2;i:2;i:10479;}i:2;i:10479;}i:363;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:10479;}i:364;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10479;}i:365;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:82:"Runtime data areas are the memory areas assigned when the JVM program runs on the ";}i:2;i:10515;}i:366;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:10597;}i:367;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:". It has five key components:";}i:2;i:10599;}i:368;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10628;}i:369;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:10628;}i:370;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10628;}i:371;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10628;}i:372;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:390:" Method area: For each .class file, the class loader generates corresponding binary data and save the class metadata (e.g. 1.Fully qualified name of the loaded class and its immediate parent class. 2. if .class file is related to a Class, Interface or Enum. 3. class modifier(public, final, etc.), static variables, and method information etc.) in the method area for each class separately.";}i:2;i:10632;}i:373;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11022;}i:374;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11022;}i:375;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11022;}i:376;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11022;}i:377;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:321:" Heap: For every .class file, class loader creates exactly one object of each class to represent .class file in the Heap memory as defined in java.lang package. This Class object can be used to read class level information (class name, parent name, methods, variable information, static variables etc.) later in our code.";}i:2;i:11026;}i:378;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11347;}i:379;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11347;}i:380;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11347;}i:381;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11347;}i:382;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" Stack:";}i:2;i:11351;}i:383;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11358;}i:384;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11358;}i:385;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11358;}i:386;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11358;}i:387;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" PC register:";}i:2;i:11362;}i:388;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11375;}i:389;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11375;}i:390;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11375;}i:391;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11375;}i:392;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Native method stack:";}i:2;i:11379;}i:393;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11400;}i:394;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11400;}i:395;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:11400;}i:396;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:11402;}i:397;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"2.1 Method area(Shared among threads)";i:1;i:3;i:2;i:11402;}i:2;i:11402;}i:398;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:11402;}i:399;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11402;}i:400;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:"The method area is a shared resource (only 1 method area per JVM). All JVM threads share this same Method area, so the ";}i:2;i:11450;}i:401;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:11569;}i:402;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:"access to the method area data and the process of dynamic linking must be thread-safe";}i:2;i:11571;}i:403;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:11656;}i:404;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:11658;}i:405;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11659;}i:406;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11659;}i:407;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"The method area stores class level data(including static variables) such as:";}i:2;i:11661;}i:408;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11737;}i:409;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:11737;}i:410;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11737;}i:411;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11737;}i:412;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Classloader reference";}i:2;i:11741;}i:413;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11763;}i:414;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11763;}i:415;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11763;}i:416;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11763;}i:417;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:345:" Run time constant pool: Numeric constants, field references, method references, attributes; As well as the constants of each class and interface, it contains all references for methods and fields. When a method or field is referred to, the JVM searches the actual address of the method or field on the memory by using the runtime constant pool.";}i:2;i:11767;}i:418;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:12112;}i:419;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:12112;}i:420;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:12112;}i:421;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:12112;}i:422;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" Field data — Per field: name, type, modifiers, attributes";}i:2;i:12116;}i:423;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:12176;}i:424;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:12176;}i:425;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:12176;}i:426;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:12176;}i:427;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:97:" Method data — Per method: name, return type, parameter types (in order), modifiers, attributes";}i:2;i:12180;}i:428;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:12277;}i:429;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:12277;}i:430;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:12277;}i:431;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:12277;}i:432;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:266:" Method code — Per method: bytecodes, operand stack size, local variable size, local variable table, exception table; Per exception handler in exception table: start point, end point, PC offset for handler code, constant pool index for exception class being caught";}i:2;i:12281;}i:433;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:12547;}i:434;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:12547;}i:435;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:12547;}i:436;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:12549;}i:437;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"2.2 Heap area(Shared among Thread)";i:1;i:3;i:2;i:12549;}i:2;i:12549;}i:438;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:12549;}i:439;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12549;}i:440;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:344:"The Heap area is also a shared resource (only 1 heap area per JVM). Information of all objects and their corresponding instance variables and arrays are stored in the Heap area. Since the Method and Heap areas share memory for multiple threads, the data stored in Method & Heap areas are not thread-safe. The Heap area is a great target for GC.";}i:2;i:12595;}i:441;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12939;}i:442;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:12941;}i:443;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"2.3 Stack area(per Thread)";i:1;i:3;i:2;i:12941;}i:2;i:12941;}i:444;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:12941;}i:445;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12941;}i:446;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:261:"For every JVM thread, when the thread starts, a separate runtime stack gets created in order to store method calls. For every such method call, one entry will be created and added (pushed) into the top of runtime stack and such entry it is called a Stack Frame.";}i:2;i:12979;}i:447;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13240;}i:448;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13240;}i:449;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"A Stack Frame is divided into three sub-entities(See figure below):";}i:2;i:13242;}i:450;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13309;}i:451;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13309;}i:452;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:42:":employes:pengfei.liu:java:stack_frame.png";i:1;s:0:"";i:2;N;i:3;s:3:"300";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:13311;}i:453;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:13362;}i:454;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13363;}i:455;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:13363;}i:456;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:13363;}i:457;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:13363;}i:458;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:328:" Local variable array: The index of the array starts with 0. All local variables of a method are stored here. At position 0, the array stores the reference of the object which the method belongs. Starts with 1, it stores the method parameters. After method parameters, it stores the local variables declared inside the method.  ";}i:2;i:13367;}i:459;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:13695;}i:460;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:13695;}i:461;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:13695;}i:462;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:13695;}i:463;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:409:" Operand stack: This acts as a runtime workspace to perform any intermediate operation if there’s a requirement. Each method exchanges data between the Operand stack and the local variable array and pushes or pops other methods invoke results. The necessary size of the Operand stack space can be determined during compiling. Therefore, the size of the Operand stack can also be determined during compiling.";}i:2;i:13699;}i:464;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:14108;}i:465;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:14108;}i:466;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:14108;}i:467;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:14108;}i:468;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:150:" Frame data: All symbols related to the method are stored here. For exceptions, the catch block information will also be maintained in the frame data.";}i:2;i:14112;}i:469;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:14262;}i:470;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:14262;}i:471;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:14262;}i:472;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14262;}i:473;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:343:"The stack frame is removed (popped) when the method returns normally or if an uncaught exception is thrown during the method invocation. Also note that if any exception occurs, each line of the stack trace (shown as a method such as printStackTrace()) expresses one stack frame. The Stack area is thread safe since it is not a shared resource.";}i:2;i:14264;}i:474;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14607;}i:475;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14607;}i:476;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:348:"Since these are runtime stack frames, after a thread terminates, its stack frame will also be destroyed by JVM.
A stack can be a dynamic or fixed size. If a thread requires a larger stack than allowed a StackOverflowError is thrown. If a thread requires a new frame and there isn’t enough memory to allocate it then an OutOfMemoryError is thrown.";}i:2;i:14609;}i:477;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14957;}i:478;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:14959;}i:479;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:28:"2.4 PC Registers(per Thread)";i:1;i:3;i:2;i:14959;}i:2;i:14959;}i:480;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:14959;}i:481;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14959;}i:482;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:372:"For each JVM thread, when the thread starts, a separate PC (Program Counter) Register gets created in order to hold the address of currently-executing instruction (memory address in the Method area). If the current method is a native method, then the PC register is undefined. Once the execution finishes, the PC register gets updated with the address of next instruction.";}i:2;i:14998;}i:483;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15370;}i:484;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:15372;}i:485;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:36:"2.5 Native Method Stack (per Thread)";i:1;i:3;i:2;i:15372;}i:2;i:15372;}i:486;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:15372;}i:487;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15372;}i:488;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:15420;}i:489;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:"There is a direct mapping between a Java thread and a native operating system thread(i.e. native thread)";}i:2;i:15422;}i:490;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:15526;}i:491;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:206:". After preparing all the state for a Java thread, a separate native stack also gets created in order to store native method information (often written in C/C++) invoked through JNI (Java Native Interface).";}i:2;i:15528;}i:492;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15734;}i:493;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15734;}i:494;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:419:"Once the native thread has been created and initialized, it invokes the run()method in the Java thread. When the run() method returns, uncaught exceptions (if any) are handled, then the native thread confirms whether the JVM needs to be terminated as a result of the thread terminating (i.e. it is the last non-deamon thread). When the thread terminates, all resources for both the native and Java threads are released.";}i:2;i:15736;}i:495;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16155;}i:496;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16155;}i:497;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:179:"The native thread is reclaimed once the Java thread terminates. The operating system is therefore responsible for scheduling all threads and dispatching them to any available CPU.";}i:2;i:16157;}i:498;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16336;}i:499;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16338;}i:500;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"3. Execution engine";i:1;i:2;i:2;i:16338;}i:2;i:16338;}i:501;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:16338;}i:502;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16338;}i:503;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:183:"The actual execution of the bytecode occurs in the Execution Engine, which executes the instructions in the bytecode line-by-line by reading the data stored in the runtime data areas.";}i:2;i:16371;}i:504;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16554;}i:505;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16554;}i:506;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"It has three key components:";}i:2;i:16556;}i:507;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16585;}i:508;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:16585;}i:509;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:16585;}i:510;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:16585;}i:511;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" Interpreter";}i:2;i:16589;}i:512;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:16601;}i:513;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:16601;}i:514;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:16601;}i:515;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:16601;}i:516;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:" Just-In-Time(JIT) Compiler";}i:2;i:16605;}i:517;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:16632;}i:518;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:16632;}i:519;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:16632;}i:520;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:16632;}i:521;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Garbage collector(GC)";}i:2;i:16636;}i:522;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:16658;}i:523;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:16658;}i:524;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:16658;}i:525;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16660;}i:526;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"3.1 Interpreter";i:1;i:3;i:2;i:16660;}i:2;i:16660;}i:527;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:16660;}i:528;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16660;}i:529;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:322:"The interpreter interprets the bytecode and executes the instructions one-by-one. Hence, it can interpret one bytecode line quickly, but executing the interpreted result is a slower task. The disadvantage is that when one method is called multiple times, each time a new interpretation and a slower execution are required.";}i:2;i:16687;}i:530;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17009;}i:531;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:17011;}i:532;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"3.2 Just-In-Time (JIT) Compiler";i:1;i:3;i:2;i:17011;}i:2;i:17011;}i:533;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:17011;}i:534;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17011;}i:535;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:319:"If only the interpreter is available, when one method is called multiple times, each time the interpretation will also occur, which is a redundant operation. The JIT compiler can compile the entire bytecode to native code(machine code). Then for repeated method calls, it directly provides the native code. Because the ";}i:2;i:17054;}i:536;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:17373;}i:537;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"execution of native code is much faster";}i:2;i:17375;}i:538;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:17414;}i:539;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:135:" than interpreting instructions one by one. The native code is stored in the CPU cache, thus the compiled code can be executed quicker.";}i:2;i:17416;}i:540;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17551;}i:541;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17551;}i:542;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:479:"But, compiling bytecode to native code takes more time than the interpreter to interpret. For a code segment that executes just once, it is better to interpret it instead of compiling it. Also, the native code is stored in the cache, which is an expensive resource. With these circumstances, the JIT compiler internally checks the frequency of each method call and decides to compile it only when the selected method has occurred more than a certain level of times. This idea of ";}i:2;i:17553;}i:543;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:18032;}i:544;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"adaptive compiling";}i:2;i:18034;}i:545;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:18052;}i:546;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:" has been used in Oracle Hotspot VMs.";}i:2;i:18054;}i:547;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18091;}i:548;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:18093;}i:549;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"3.3 Garbage collector (GC)";i:1;i:3;i:2;i:18093;}i:2;i:18093;}i:550;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:18093;}i:551;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18093;}i:552;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:435:"As long as an object is being referenced, the JVM considers it alive. Once an object is no longer referenced and therefore is not reachable by the application code, the garbage collector removes it and reclaims the memory. In general, garbage collection happens under the hood, however, we can trigger it by calling System.gc() method (Again the execution is not guaranteed. Hence, call Thread.sleep(1000) and wait for GC to complete).";}i:2;i:18131;}i:553;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18566;}i:554;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:18568;}i:555;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"3.4 JVM performance optimizations";i:1;i:3;i:2;i:18568;}i:2;i:18568;}i:556;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:18568;}i:557;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18568;}i:558;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:154:"Execution Engine is a key subsystem for JVM performance optimizations. Among such efforts, the following 4 components can largely improve its performance.";}i:2;i:18613;}i:559;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18767;}i:560;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:18767;}i:561;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:18767;}i:562;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:18767;}i:563;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:18771;}i:564;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:18772;}i:565;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"Intermediate Code Generator";}i:2;i:18774;}i:566;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:18801;}i:567;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:" produces intermediate code.";}i:2;i:18803;}i:568;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:18831;}i:569;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:18831;}i:570;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:18831;}i:571;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:18831;}i:572;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:18835;}i:573;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:18836;}i:574;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:"Code Optimizer";}i:2;i:18838;}i:575;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:18852;}i:576;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" is responsible for optimizing the intermediate code generated above.";}i:2;i:18854;}i:577;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:18923;}i:578;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:18923;}i:579;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:18923;}i:580;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:18923;}i:581;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:18927;}i:582;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:18928;}i:583;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"Target Code Generator";}i:2;i:18930;}i:584;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:18951;}i:585;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:" is responsible for generating Native Code (i.e. Machine Code).";}i:2;i:18953;}i:586;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:19016;}i:587;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:19016;}i:588;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:19016;}i:589;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:19016;}i:590;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:19020;}i:591;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:19021;}i:592;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"Profiler";}i:2;i:19023;}i:593;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:19031;}i:594;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:147:" is a special component, responsible for finding performance bottlenecks a.k.a. hotspots (e.g. instances where one method is called multiple times)";}i:2;i:19033;}i:595;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:19180;}i:596;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:19180;}i:597;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:19180;}i:598;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:19183;}i:599;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:45:"Vendor Approaches for Compiling Optimizations";i:1;i:4;i:2;i:19183;}i:2;i:19183;}i:600;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:19183;}i:601;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:19238;}i:602;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"Oracle Hotspot VMs";i:1;i:5;i:2;i:19238;}i:2;i:19238;}i:603;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:19238;}i:604;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19238;}i:605;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:711:"Oracle has 2 implementations of their standard Java VMs with a popular JIT compiler model called Hotspot Compiler. Through profiling, it can identify the hotspots that require JIT compiling the most and then compile those performance-critical portions of the code to native code. Over time, if such a compiled method is no longer frequently invoked, it identifies the method as no longer a hotspot and quickly removes the native code from the cache and starts running in interpreter mode. This methodology creates a boost in performance while avoiding unnecessary compilation of seldom used code. Additionally, on the fly, the Hotspot Compiler decides how best to optimize compiled code with techniques such as ";}i:2;i:19264;}i:606;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:19975;}i:607;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"in lining";}i:2;i:19976;}i:608;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:19985;}i:609;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:". The run time analysis performed by the compiler allows it to eliminate the guesswork in determining which optimizations will yield the largest performance benefit.";}i:2;i:19986;}i:610;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20151;}i:611;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20151;}i:612;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:100:"The different vms use different custom-built implementations of the JIT compiler as mentioned below.";}i:2;i:20153;}i:613;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20253;}i:614;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:20253;}i:615;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:20253;}i:616;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:20253;}i:617;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:20257;}i:618;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:20258;}i:619;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"Oracle Java Hotspot Client VM";}i:2;i:20260;}i:620;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:20289;}i:621;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:196:" is the default VM technology for Oracle JDK and JRE. It is tuned for best performance when running applications in a client environment by reducing application start up time and memory footprint.";}i:2;i:20291;}i:622;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:20487;}i:623;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:20487;}i:624;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:20487;}i:625;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:20487;}i:626;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:20491;}i:627;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:20492;}i:628;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"Oracle Java Hotspot Server VM";}i:2;i:20494;}i:629;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:20523;}i:630;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:346:" is designed for maximum program execution speed for applications running in a server environment. The JIT compiler used here is called Advanced Dynamic Optimizing Compiler and uses more complex and diverse performance optimization techniques. The Java HotSpot Server VM is invoked by using the server command line option (e.g. java server MyApp)";}i:2;i:20525;}i:631;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:20871;}i:632;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:20871;}i:633;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:20871;}i:634;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20871;}i:635;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:199:"The Oracle’s Java Hotspot technology is famous for its rapid memory allocation, fast and efficient GC, and readily-scalable thread-handling capability in large shared-memory multiprocessor servers.";}i:2;i:20873;}i:636;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21072;}i:637;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21074;}i:638;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"IBM AOT (Ahead-Of-Time) Compiling";i:1;i:5;i:2;i:21074;}i:2;i:21074;}i:639;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:5;}i:2;i:21074;}i:640;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21074;}i:641;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:320:"These JVMs share the native code compiled through the shared cache, thus the code that has been already compiled through the AOT compiler can be used by another JVM without compiling. In addition, IBM JVM provides a fast way of execution by pre-compiling code to JXE (Java Executable) file format using the AOT compiler.";}i:2;i:21115;}i:642;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21435;}i:643;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21438;}i:644;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"4. Java Native Interface (JNI)";i:1;i:2;i:2;i:21438;}i:2;i:21438;}i:645;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:21438;}i:646;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21438;}i:647;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:282:"This interface is used to interact with Native Method Libraries required for the execution and provide the capabilities of such Native Libraries (often written in C/C++). This enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.";}i:2;i:21482;}i:648;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21764;}i:649;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21766;}i:650;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"5. Native Method Libraries";i:1;i:2;i:2;i:21766;}i:2;i:21766;}i:651;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:21766;}i:652;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21766;}i:653;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"This is a collection of C/C++ Native Libraries which is required for the Execution Engine and can be accessed through the provided Native Interface.";}i:2;i:21805;}i:654;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21953;}i:655;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21956;}i:656;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:11:"JVM Threads";i:1;i:1;i:2;i:21956;}i:2;i:21956;}i:657;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:21956;}i:658;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21956;}i:659;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:398:"We discussed how a Java program gets executed, but didn’t specifically mention the executors. Actually, to perform each task we discussed earlier, the JVM concurrently runs multiple threads. Some of these threads carry the programming logic and are created by the program (application threads), while the rest is created by JVM itself to undertake background tasks in the system (system threads).";}i:2;i:21983;}i:660;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22381;}i:661;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22381;}i:662;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:333:"The main application thread is created by invoking public static void main(String[]) and all other application threads are created by this main thread. Application threads perform tasks such as executing instructions starting with the main() method, creating objects in the Heap area if it finds new keyword in any method logic, etc.";}i:2;i:22383;}i:663;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22716;}i:664;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22716;}i:665;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:"The major system threads are as follows:";}i:2;i:22718;}i:666;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22758;}i:667;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:22758;}i:668;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:22758;}i:669;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:22758;}i:670;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:22762;}i:671;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:22763;}i:672;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"Compiler threads";}i:2;i:22765;}i:673;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:22781;}i:674;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:": At runtime, these threads compile bytecode to native code.";}i:2;i:22783;}i:675;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:22843;}i:676;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:22843;}i:677;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:22843;}i:678;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:22843;}i:679;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:22847;}i:680;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:22848;}i:681;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"GC threads";}i:2;i:22850;}i:682;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:22860;}i:683;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:65:": All the GC related activities are carried out by these threads.";}i:2;i:22862;}i:684;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:22927;}i:685;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:22927;}i:686;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:22927;}i:687;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:22927;}i:688;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:22931;}i:689;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:22932;}i:690;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"Periodic task thread";}i:2;i:22934;}i:691;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:22954;}i:692;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:": The timer events (i.e. interrupts) to schedule execution of periodic operations are performed by this thread.";}i:2;i:22956;}i:693;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23067;}i:694;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23067;}i:695;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23067;}i:696;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23067;}i:697;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:23071;}i:698;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:23072;}i:699;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"Signal dispatcher thread";}i:2;i:23074;}i:700;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:23098;}i:701;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:126:": This thread receives signals sent to the JVM process and handles them inside the JVM by calling the appropriate JVM methods.";}i:2;i:23100;}i:702;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23226;}i:703;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23226;}i:704;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23226;}i:705;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23226;}i:706;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:23230;}i:707;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:23231;}i:708;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"VM thread";}i:2;i:23233;}i:709;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:23242;}i:710;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:352:": As a pre-condition, some operations need the JVM to arrive at a safe point where modifications to the Heap area does no longer happen. Examples for such scenarios are “stop-the-world” garbage collections, thread stack dumps, thread suspension, and biased locking revocation. These operations can be performed on a special thread called VM thread.";}i:2;i:23244;}i:711;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23596;}i:712;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23596;}i:713;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:23596;}i:714;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:23598;}i:715;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:10:"JVM Tuning";i:1;i:1;i:2;i:23598;}i:2;i:23598;}i:716;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:23598;}i:717;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23598;}i:718;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:"General JVM Tuning Considerations";}i:2;i:23623;}i:719;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23656;}i:720;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:23656;}i:721;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23656;}i:722;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23656;}i:723;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" Jvm vendor and version";}i:2;i:23660;}i:724;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23683;}i:725;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23683;}i:726;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23683;}i:727;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23683;}i:728;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Tuning Heap size";}i:2;i:23687;}i:729;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23704;}i:730;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23704;}i:731;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23704;}i:732;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23704;}i:733;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:" Tuning GC and choose an appropriate GC scheme.";}i:2;i:23708;}i:734;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23755;}i:735;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23755;}i:736;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:23755;}i:737;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23755;}i:738;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"Oracle doc on jvm running for Weblogic server ";}i:2;i:23758;}i:739;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:76:"https://docs.oracle.com/cd/E15523_01/web.1111/e13814/jvm_tuning.htm#PERFM154";i:1;N;}i:2;i:23804;}i:740;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23880;}i:741;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:23881;}i:742;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:23881;}}