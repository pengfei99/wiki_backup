a:411:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"Java Memory Model";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"Understanding the Java Memory Model is essential for learning how to develop, deploy, monitor, test, and tune the performance of a Java application.";}i:2;i:34;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:182;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:182;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"JVM consumes the available space on your host ";}i:2;i:184;}i:8;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:230;}i:9;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:" memory just like any other software. See the below figure.";}i:2;i:232;}i:10;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:291;}i:11;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:291;}i:12;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:41:":employes:pengfei.liu:java:jvm_memory.png";i:1;s:0:"";i:2;N;i:3;s:3:"400";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:293;}i:13;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:343;}i:14;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:343;}i:15;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:137:"Java Memory Model(JMM) is a specification which guarantees visibilities of fields(aka. happens before) amidst reordering of instructions ";}i:2;i:345;}i:16;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:482;}i:17;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:484;}i:18;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:36:"Summary of JVM memory configurations";i:1;i:2;i:2;i:484;}i:2;i:484;}i:19;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:484;}i:20;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:484;}i:21;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:127:"Pay attention to the permanent generation setting. Because since Java 8, the permanent generation is replaced by the Metaspace.";}i:2;i:533;}i:22;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:660;}i:23;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1047:"
-XmsSetting — initial Heap size
-XmxSetting — maximum Heap size
-XX:NewSizeSetting — new generation heap size
-XX:MaxNewSizeSetting — maximum New generation heap size
-XX:SurvivorRatioSetting — new heap size ratios (e.g. if Young Gen size is 10m and memory switch is –XX:SurvivorRatio=2, then 5m will be reserved for Eden space and 2.5m each for both Survivor spaces, default value = 8)
-XX:NewRatio — providing ratio of Old/New Gen sizes (default value = 2)

# Before Java 8, 
-XX:PermSize -- initial size of Permanent generation
-XX:MaxPermGenSetting — maximum size of Permanent generation

# Since Java 8, the permanent generation is replaced by the Metaspace.
-XX:MetaspaceSize -- It defines the initial size of metaspace. If you don’t specify this flag, the Metaspace will dynamically re-size depending on the application demand at runtime. 
-XX:MaxMetaspaceSize -- It defines the maximum size of metaspace. If you don’t specify this flag, the default is unlimited, which means that only your system memory is the limit.
";i:1;N;i:2;N;}i:2;i:667;}i:24;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1724;}i:25;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"1. JVM memory spaces";i:1;i:2;i:2;i:1724;}i:2;i:1724;}i:26;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1724;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1724;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:"Inside JVM, there exist separate memory spaces:";}i:2;i:1758;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1805;}i:30;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:1805;}i:31;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1805;}i:32;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1805;}i:33;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" Heap";}i:2;i:1809;}i:34;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1814;}i:35;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1814;}i:36;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1814;}i:37;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1814;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" Non-Heap";}i:2;i:1818;}i:39;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1827;}i:40;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1827;}i:41;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1827;}i:42;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1827;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" Cache";}i:2;i:1831;}i:44;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1837;}i:45;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1837;}i:46;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1837;}i:47;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1837;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" Stack";}i:2;i:1841;}i:49;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1847;}i:50;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1847;}i:51;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:1847;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1847;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:"The below figure shows an overview of all JVM memory key components.";}i:2;i:1849;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1917;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1917;}i:56;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:56:":employes:pengfei.liu:java:jvm_memory_key_components.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:1919;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1984;}i:58;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1986;}i:59;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"1.1 Heap Memory";i:1;i:3;i:2;i:1986;}i:2;i:1986;}i:60;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1986;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1986;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:368:"The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.). It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.";}i:2;i:2013;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2381;}i:64;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2381;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:"Static class variables are also stored on the heap along with the class definition.";}i:2;i:2383;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2466;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2466;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:374:"Objects on the heap can be accessed by all threads that have a reference to the object. When a thread has access to an object, it can also get access to that object's member variables. If two threads call a method on the same object at the same time, they will both have access to the object's member variables, but each thread will have its own copy of the local variables.";}i:2;i:2468;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2842;}i:70;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2842;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:"The heap memory is divided into two parts:";}i:2;i:2844;}i:72;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2886;}i:73;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:2886;}i:74;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2886;}i:75;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2886;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Young Generation";}i:2;i:2890;}i:77;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2907;}i:78;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2907;}i:79;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2907;}i:80;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2907;}i:81;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" Old Generation";}i:2;i:2911;}i:82;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2926;}i:83;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2926;}i:84;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:2926;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2926;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"The heap memory is allocated when JVM starts up. Its initial size can be configured by using ";}i:2;i:2928;}i:87;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3021;}i:88;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3023;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"-Xms";}i:2;i:3024;}i:90;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3028;}i:91;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3029;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:" flag. Its maximum size can be configured by using ";}i:2;i:3031;}i:93;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3082;}i:94;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:3084;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"-Xmx";}i:2;i:3085;}i:96;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:3089;}i:97;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3090;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:". Runtime Heap size increases/decreases while the application is running. ";}i:2;i:3092;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3166;}i:100;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3168;}i:101;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"1.1.1 Young Generation";i:1;i:4;i:2;i:3168;}i:2;i:3168;}i:102;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:3168;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3168;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:97:"The young Generation is reserved for containing newly-allocated objects. It contains three parts:";}i:2;i:3200;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3297;}i:106;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:3297;}i:107;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3297;}i:108;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3297;}i:109;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:" Eden memory: It stores most of the newly-created objects.";}i:2;i:3301;}i:110;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3359;}i:111;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3359;}i:112;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3359;}i:113;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3359;}i:114;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:" Survivor memory S0: It stores the objects which are survived the young collection GC ";}i:2;i:3363;}i:115;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3449;}i:116;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3449;}i:117;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3449;}i:118;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3449;}i:119;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" Survivor memory S1: idem to S0";}i:2;i:3453;}i:120;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3484;}i:121;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3484;}i:122;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:3484;}i:123;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3484;}i:124;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:102:"Most of the newly-created objects are stored in Eden space. When Eden space is filled with objects, a ";}i:2;i:3486;}i:125;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3588;}i:126;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"Minor GC";}i:2;i:3590;}i:127;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3598;}i:128;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" (a.k.a. ";}i:2;i:3600;}i:129;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3609;}i:130;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"Young Collection";}i:2;i:3611;}i:131;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3627;}i:132;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:214:") is performed and all the survivor objects are moved to the survivor spaces S0. Minor GC also checks the survivor objects and move them to the other survivor space. It always keeps one of the survivor space empty.";}i:2;i:3629;}i:133;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3843;}i:134;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3843;}i:135;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"Objects that are survived after many cycles of GC are moved to the ";}i:2;i:3845;}i:136;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3912;}i:137;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"Old generation memory";}i:2;i:3914;}i:138;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3935;}i:139;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:153:" space. Usually, it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.";}i:2;i:3937;}i:140;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4090;}i:141;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4092;}i:142;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"1.1.2 Old Generation";i:1;i:4;i:2;i:4092;}i:2;i:4092;}i:143;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:4092;}i:144;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4092;}i:145;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:"Old generation memory stores long-lived objects that survived after many rounds of Minor GC. When Old Gen space is full, ";}i:2;i:4122;}i:146;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4243;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"Major GC";}i:2;i:4245;}i:148;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4253;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" (a.k.a. ";}i:2;i:4255;}i:150;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4264;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:"Old Collection";}i:2;i:4266;}i:152;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4280;}i:153;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:57:") is performed (usually takes more time than a minor GC).";}i:2;i:4282;}i:154;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4339;}i:155;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4339;}i:156;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:122:"Below figure shows an overview of heap memory and the minor GC, major GC move objects from young to old generation memory ";}i:2;i:4342;}i:157;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4464;}i:158;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4464;}i:159;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:42:":employes:pengfei.liu:java:heap_memory.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:4466;}i:160;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4517;}i:161;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4520;}i:162;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"1.2 Non-Heap memory";i:1;i:3;i:2;i:4520;}i:2;i:4520;}i:163;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4520;}i:164;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4520;}i:165;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"Non-Heap memory A.K.A  ";}i:2;i:4551;}i:166;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4574;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"Permanent Generation(";}i:2;i:4576;}i:168;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4597;}i:169;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"Replaced";}i:2;i:4598;}i:170;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4606;}i:171;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:" by Metaspace since Java 8)";}i:2;i:4607;}i:172;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4634;}i:173;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:309:". It includes a method area shared by all threads. It includes also memory required for the internal processing and optimization for the JVM. Perm Gen stores per-class structures such as runtime constant pool, field and method data, and the code for methods and constructors, as well as interned Strings(e.g. ";}i:2;i:4636;}i:174;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4945;}i:175;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"John";}i:2;i:4946;}i:176;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4950;}i:177;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:56:"). Since Java 8, these data will be stored in metaspace.";}i:2;i:4951;}i:178;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5007;}i:179;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5011;}i:180;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"PermGen vs Metaspace";i:1;i:4;i:2;i:5011;}i:2;i:5011;}i:181;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:5011;}i:182;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5011;}i:183;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:"The key difference is that PermGen is part of JVM memory, ";}i:2;i:5041;}i:184;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:5099;}i:185;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"Metaspace is NOT part of JVM memory";}i:2;i:5101;}i:186;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:5136;}i:187;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:116:". Rather Metaspace is part of Native Memory (jvm process memory) which is only limited by the Host Operating System.";}i:2;i:5138;}i:188;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5254;}i:189;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5254;}i:190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:32:"The advantages of metaspace are:";}i:2;i:5256;}i:191;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5288;}i:192;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:5288;}i:193;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5288;}i:194;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5288;}i:195;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:" Take advantage of Java Language Specification property: Classes and associated metadata lifetimes match class loader’s";}i:2;i:5292;}i:196;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5413;}i:197;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5413;}i:198;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5413;}i:199;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5413;}i:200;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:" Per loader storage area – Metaspace";}i:2;i:5417;}i:201;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5455;}i:202;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5455;}i:203;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5455;}i:204;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5455;}i:205;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" Linear allocation only";}i:2;i:5459;}i:206;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5482;}i:207;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5482;}i:208;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5482;}i:209;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5482;}i:210;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:" No individual reclamation (except for RedefineClasses and class loading failure)";}i:2;i:5486;}i:211;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5567;}i:212;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5567;}i:213;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5567;}i:214;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5567;}i:215;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" No GC scan or compaction";}i:2;i:5571;}i:216;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5596;}i:217;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5596;}i:218;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:5596;}i:219;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:5596;}i:220;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:" No relocation for metaspace objects ";}i:2;i:5600;}i:221;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:5637;}i:222;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:5637;}i:223;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:5637;}i:224;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5637;}i:225;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:459:"You will NOT run out of PermGen space anymore (since there is NO PermGen), you may consume excessive Native memory making the total process size large. The issue is, if your application loads lots of classes (and/or interned strings), you may actually bring down the Entire Server (not just your application). Why ? Because the native memory is only limited by the Operating System. This means you can literally take up all the memory on the Server. Not good.";}i:2;i:5639;}i:226;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6098;}i:227;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6098;}i:228;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"Another issue for java application memory monitoring. Such as ";}i:2;i:6100;}i:229;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:6162;}i:230;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"jmap -permstat <PID>";}i:2;i:6163;}i:231;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:6183;}i:232;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:232:" will not work anymore. Because metaspace is process memory not part of Heap. You need to keep an eye on the ‘process size’ using your Operating System utilities (Example: ‘top’ in Unix/Linux, ‘Task Manager’ in Windows).";}i:2;i:6184;}i:233;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6416;}i:234;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6419;}i:235;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"1.3 Cache Memory";i:1;i:3;i:2;i:6419;}i:2;i:6419;}i:236;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6419;}i:237;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6419;}i:238;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"Cache Memory includes ";}i:2;i:6447;}i:239;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:6469;}i:240;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"Code Cache";}i:2;i:6471;}i:241;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:6481;}i:242;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:261:", which stores compiled code (i.e. native code) generated by JIT compiler, JVM internal structures, loaded profiler agent code and data, etc. When Code Cache exceeds a threshold, it gets flushed (and objects are not relocated by the GC, so objects are deleted).";}i:2;i:6483;}i:243;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6744;}i:244;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6747;}i:245;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"1.4 Stack Memory";i:1;i:3;i:2;i:6747;}i:2;i:6747;}i:246;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6747;}i:247;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6747;}i:248;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:629:"Java Stack memory is used for the execution of a thread. It contains information about what methods the thread has called to reach the current point of execution. It also contains all local variables for each method being executed (all methods on the call stack). A thread can only access its own thread stack. Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code, the two threads will still create the local variables of that code in each their own thread stack. Thus, each thread has its own version of each local variable.";}i:2;i:6775;}i:249;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7404;}i:250;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7404;}i:251;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:301:"All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads. One thread may pass a copy of a primitive variable to another thread, but it cannot share the primitive local variable itself.";}i:2;i:7406;}i:252;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7707;}i:253;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7707;}i:254;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:368:"The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.). It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.";}i:2;i:7709;}i:255;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8077;}i:256;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8077;}i:257;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"So If a local variable is a reference of an object, the reference is stored in the stack, the object is stored in the Heap. ";}i:2;i:8079;}i:258;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8203;}i:259;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8205;}i:260;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"1.4.1 Stack vs Heap";i:1;i:4;i:2;i:8205;}i:2;i:8205;}i:261;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:8205;}i:262;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8205;}i:263;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"The below figure shows the differences between Stack and Heap.";}i:2;i:8235;}i:264;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8297;}i:265;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8297;}i:266;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:44:":employes:pengfei.liu:java:stack_vs_heap.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:8299;}i:267;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8352;}i:268;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8355;}i:269;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"1.4.2 An example of stack and heap";i:1;i:4;i:2;i:8355;}i:2;i:8355;}i:270;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:8355;}i:271;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8355;}i:272;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:159:"So for a java application to run, stack and heap work together. For example, for
the following code. You will have a stack and heap memory in the below figure.";}i:2;i:8399;}i:273;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8558;}i:274;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:278:"
class Person {
    int pid;
    String name;
     
    // constructor, setters/getters
}
 
public class Driver {
    public static void main(String[] args) {
        int id = 23;
        String pName = "Jon";
        Person p = null;
        p = new Person(id, pName);
    }
}
";i:1;N;i:2;N;}i:2;i:8565;}i:275;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8565;}i:276;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:49:":employes:pengfei.liu:java:stack_heap_example.jpg";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:8853;}i:277;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8911;}i:278;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8911;}i:279;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"Let's analyze the code step by step:";}i:2;i:8913;}i:280;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8949;}i:281;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8949;}i:282;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:324:"1. Entering the main() method, a space in stack memory would be created to store primitives and references of this method. The primitive value of integer id will be stored directly in stack memory. The reference variable p of type Person will also be created in stack memory which will point to the actual object in the heap";}i:2;i:8951;}i:283;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9275;}i:284;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9275;}i:285;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:"2. The call to the parameterized constructor Person(int, String) from main() will allocate further memory on top of the previous stack. This will store:";}i:2;i:9277;}i:286;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9429;}i:287;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:9429;}i:288;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9429;}i:289;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9429;}i:290;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" The ";}i:2;i:9433;}i:291;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:9438;}i:292;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"this";}i:2;i:9439;}i:293;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:9443;}i:294;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:" object reference of the calling object in stack memory";}i:2;i:9444;}i:295;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9499;}i:296;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9499;}i:297;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9499;}i:298;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9499;}i:299;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:43:" The primitive value id in the stack memory";}i:2;i:9503;}i:300;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9546;}i:301;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9546;}i:302;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9546;}i:303;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9546;}i:304;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:" The reference variable of String argument personName which will point to the actual string from string pool in heap memory";}i:2;i:9550;}i:305;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9673;}i:306;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9673;}i:307;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:9673;}i:308;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9673;}i:309;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:218:"3. This default constructor is further calling setPersonName() method, for which further allocation will take place in stack memory on top of previous one. This will again store variables in the manner described above.";}i:2;i:9675;}i:310;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9893;}i:311;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9893;}i:312;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:112:"4. However, for the newly created object p of type Person, all instance variables will be stored in heap memory.";}i:2;i:9895;}i:313;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10007;}i:314;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10010;}i:315;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"2. Hardware memory architecture";i:1;i:2;i:2;i:10010;}i:2;i:10010;}i:316;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:10010;}i:317;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10010;}i:318;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:218:"Modern hardware memory architecture is somewhat different from the internal Java memory model. It is important to understand the hardware memory architecture too, to understand how the Java memory model works with it. ";}i:2;i:10055;}i:319;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10273;}i:320;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10273;}i:321;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:"The below figure shows a simplified diagram of modern computer hardware architecture.";}i:2;i:10275;}i:322;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10360;}i:323;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10360;}i:324;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:52:":employes:pengfei.liu:java:hardware_memory_model.png";i:1;s:0:"";i:2;N;i:3;s:3:"400";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:10362;}i:325;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10423;}i:326;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10423;}i:327;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:439:"A modern computer often has 2 or more CPUs in it. Some of these CPUs may have multiple cores too. The point is, that on a modern computer with 2 or more CPUs it is possible to have more than one thread running simultaneously. Each CPU is capable of running one thread at any given time. That means that if your Java application is multithreaded, one thread per CPU may be running simultaneously (concurrently) inside your Java application.";}i:2;i:10425;}i:328;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10864;}i:329;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10864;}i:330;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:279:"Each CPU contains a set of registers which are essentially in-CPU memory. The CPU can perform operations much faster on these registers than it can perform on variables in main memory. That is because the CPU can access these registers much faster than it can access main memory.";}i:2;i:10866;}i:331;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11145;}i:332;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11145;}i:333;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:349:"Each CPU may also have a CPU cache memory layer. In fact, most modern CPUs have a cache memory layer of some size. The CPU can access its cache memory much faster than main memory, but typically not as fast as it can access its internal registers. So, the CPU cache memory is somewhere in between the speed of the internal registers and main memory.";}i:2;i:11147;}i:334;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11496;}i:335;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11496;}i:336;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:172:"A computer also contains the main memory area (RAM). All CPUs can access the main memory. The main memory area is typically much bigger than the cache memories of the CPUs.";}i:2;i:11498;}i:337;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11670;}i:338;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11670;}i:339;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:402:"Typically, when a CPU needs to access the main memory it will read part of the main memory into its CPU cache. It may even read part of the cache into its internal registers and then perform operations on it. When the CPU needs to write the result back to the main memory it will flush the value from its internal register to the cache memory, and at some point flush the value back to the main memory.";}i:2;i:11672;}i:340;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12074;}i:341;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12074;}i:342;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:385:"The values stored in the cache memory is typically flushed back to main memory when the CPU needs to store something else in the cache memory. The CPU cache can have data written to part of its memory at a time and flush part of its memory at a time. It does not have to read/write the full cache each time it is updated. Typically the cache is updated in smaller memory blocks called ";}i:2;i:12076;}i:343;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:12461;}i:344;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"cache lines";}i:2;i:12462;}i:345;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:12473;}i:346;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:130:". One or more cache lines may be read into the cache memory, and one or more cache lines may be flushed back to main memory again.";}i:2;i:12474;}i:347;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12604;}i:348;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:12607;}i:349;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:86:"3. Bridging The Gap Between The Java Memory Model And The Hardware Memory Architecture";i:1;i:2;i:2;i:12607;}i:2;i:12607;}i:350;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:12607;}i:351;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12607;}i:352;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:275:"The hardware memory architecture does not distinguish between thread stacks and heap. On the hardware, both the thread stack and the heap are located in the main memory. Parts of the thread stacks and heap may sometimes be present in CPU caches and in internal CPU registers.";}i:2;i:12708;}i:353;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12983;}i:354;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12983;}i:355;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:"When objects and variables can be stored in various different memory areas in the computer, certain problems may occur. The two main problems are:";}i:2;i:12985;}i:356;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13132;}i:357;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:13132;}i:358;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:13132;}i:359;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:13132;}i:360;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:" Visibility of thread updates (writes) to shared variables.";}i:2;i:13136;}i:361;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:13195;}i:362;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:13195;}i:363;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:13195;}i:364;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:13195;}i:365;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" Race conditions when reading, checking and writing shared variables.";}i:2;i:13199;}i:366;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:13268;}i:367;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:13268;}i:368;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:13268;}i:369;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:13270;}i:370;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:32:"3.1 Visibility of Shared Objects";i:1;i:3;i:2;i:13270;}i:2;i:13270;}i:371;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:13270;}i:372;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13270;}i:373;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:205:"If two or more threads are sharing an object, without the proper use of either volatile declarations or synchronization, updates to the shared object made by one thread may not be visible to other threads.";}i:2;i:13314;}i:374;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13519;}i:375;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13519;}i:376;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:466:"Imagine that the shared object is initially stored in the main memory. A thread running on CPU one then reads the shared object into its CPU cache. There it makes a change to the shared object. As long as the CPU cache has not been flushed back to main memory, the changed version of the shared object is not visible to threads running on other CPUs. This way each thread may end up with its own copy of the shared object, each copy sitting in a different CPU cache.";}i:2;i:13521;}i:377;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13987;}i:378;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13987;}i:379;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:317:"The following diagram illustrates the sketched situation. One thread running on the left CPU copies the shared object into its CPU cache and changes its count variable to 2. This change is not visible to other threads running on the right CPU, because the update to count has not been flushed back to main memory yet.";}i:2;i:13989;}i:380;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14306;}i:381;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14306;}i:382;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:50:":employes:pengfei.liu:java:variable_visibility.png";i:1;s:0:"";i:2;N;i:3;s:3:"400";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:14308;}i:383;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14367;}i:384;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14367;}i:385;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:207:"To solve this problem you can use Java's volatile keyword. The volatile keyword can make sure that a given variable is read directly from the main memory, and always written back to main memory when updated.";}i:2;i:14369;}i:386;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14576;}i:387;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:14578;}i:388;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"3.2 Race Conditions";i:1;i:3;i:2;i:14578;}i:2;i:14578;}i:389;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:14578;}i:390;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14578;}i:391;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:"if two or more threads share an object, and more than one thread updates variables in that shared object, race conditions may occur.";}i:2;i:14609;}i:392;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14741;}i:393;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14741;}i:394;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:282:"Imagine if thread A reads the variable count of a shared object into its CPU cache. Imagine too, that thread B does the same, but into a different CPU cache. Now thread A adds one to count, and thread B does the same. Now var1 has been incremented two times, once in each CPU cache.";}i:2;i:14743;}i:395;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15025;}i:396;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15025;}i:397;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:"If these increments had been carried out sequentially, the variable count would be been incremented twice and had the original value + 2 written back to main memory.";}i:2;i:15027;}i:398;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15192;}i:399;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15192;}i:400;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:287:"However, the two increments have been carried out concurrently without proper synchronization. Regardless of which of thread A and B that writes its updated version of count back to main memory, the updated value will only be 1 higher than the original value, despite the two increments.";}i:2;i:15194;}i:401;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15481;}i:402;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15481;}i:403;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"To solve this problem you can use a ";}i:2;i:15483;}i:404;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:15519;}i:405;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"Java synchronized block";}i:2;i:15521;}i:406;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:15544;}i:407;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:426:". A synchronized block guarantees that only one thread can enter a given critical section of the code at any given time. Synchronized blocks also guarantee that all variables accessed inside the synchronized block will be read in from main memory, and when the thread exits the synchronized block, all updated variables will be flushed back to main memory again, regardless of whether the variable is declared volatile or not.";}i:2;i:15546;}i:408;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15972;}i:409;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:15972;}i:410;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:15972;}}