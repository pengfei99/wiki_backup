====== Java job interview questions ======

===== The basics of JAVA, jvm, and compile process =====



==== 1. Java is a compile or interpret language? ====


1. Java source code (use javac)-> Java bytecode
2. Run bytecode on java run time environment

There are three way to run bytecode. 

  * JVM interpret java bytecode line by line
  * The JIT(Just in time compiler) compiler is enabled by default, and is activated when a Java method is called. The JIT compiler compiles the bytecode of that method into native machine code, compiling it "just in time" to run. When a method has been compiled, the JVM calls the compiled code of that method directly instead of interpreting it
  * RTSJ (Real time Specification for JAVA) is another type of java runtime environment. This is designed for real time programming. IBM WebSphere Real Time is an example

Most of the java programe use the hotspot jvm (include a jvm and jit). RSTJ is used for real time devices only.

==== 2. What is a JVM and hotspot? ====

The JVM is by definition a virtual machine, that is a software machine that simulates what a real machine does. Like real machines it has an instruction set, a virtual computer architecture and an execution model. It is capable of running code written with this virtual instruction set, pretty much like a real machine can run machine code.

HotSpot is an an implementation of the JVM concept, originally developed by Sun and now owned by Oracle. There are other implementations of the JVM specification, like JRockit, IBM J9, among many others.

The OpenJDK is a project under which an opensource implementation of the HotSpot (and many other things e.g compiler, JDK APIs, etc) is developed.

==== 3. What is a JAVA AOT compiler? ====

AOT is stand for ahead of time.

To make a code run on a pc, you need to have runtime environment to run the code and warp system calls to the os.

All programs have a runtime environment. Standard lib for C that wraps system calls to the operating system. Objective-C has its runtime that wraps all of its message passing.

With Java, the runtime is the JVM. Most of the Java implementations that people are familiar with are similar to the HotSpot JVM which is a byte code interpreter and JIT compiler.

This doesn't have to be the only implementation. There is absolutely nothing saying you can't build a standard lib-esque runtime for Java and compile the code to native machine code and run that within the runtime that handles calls for new objects into mallocs and file access into system calls on the machine. And thats what the Ahead Of Time (AOT rather than JIT) compiler does. Call that runtime what you will... you could call it a JVM implementation (and it does follow the JVM specification) or a runtime environment or standard lib for Java. Its there and it does essentially the same thing.

It could be done either by reimplementing javac to target the native machine (that's kind of what GCJ did). Or it could be done with translating the byte code generated by javac into machine (or byte) code for another machine - that's what Android does. Based on Wikipedia that's what Excelsior JET does too ("The compiler transforms the portable Java byte code into optimized executables for the desired hardware and operating system (OS)"), and the same is true for RoboVM.

There are additional complications with Java that means this is very hard to do as an exclusive approach. Dynamic loading of classes (class.forName()) or proxied objects require dynamics that AOT compilers do not easily provide and so their respective JVMs must also include either a JIT compiler (Excelsior JET) or an interpreter (GCJ) to handle classes that couldn't be precompiled into native.

Remember, the JVM is a specification, with many implementations. The C standard library is also a specification with many different implementations.

With Java8, a fair bit of work has been done on AOT compilation. At best, one can only summarize AOT in general within the confines of a textbox. However, in the JVM Language Summit for 2015 (August of 2015), there was a presentation: Java Goes AOT (youtube video). This video is 40 minutes long and goes into many of the deeper technical aspects and performance benchmarks.

==== 4. what is Classpath? ====

Classpath is a parameter in the Java Virtual Machine or the Java compiler that specifies the location of user-defined classes and packages. The parameter may be set either on the command-line or through an environment variable.

Similar to the classic dynamic loading behavior, when executing Java programs, the Java Virtual Machine finds and loads classes lazily (it loads the bytecode of a class only when the class is first used). The classpath tells Java where to look in the filesystem for files defining these classes.

The virtual machine searches for and loads classes in this order:

  - bootstrap classes: the classes that are fundamental to the Java Platform (comprising the public classes of the Java Class Library, and the private classes that are necessary for this library to be functional).
  - extension classes: packages that are in the extension directory of the JRE or JDK, jre/lib/ext/
  - user-defined packages and libraries

By default only the packages of the JDK standard API and extension packages are accessible without needing to set where to find them. The path for all user-defined packages and libraries must be set in the command-line (or in the Manifest associated with the Jar file containing the classes).

=== Set class path in a java app ===

Suppose we have a package called org.mypackage containing the classes:

  * HelloWorld (main class)
  * SupportClass
  * UtilClass

and the files defining this package are stored physically under the directory /home/user/myprogram (on Linux).

The file structure looks like this:

<code>
/home/user/myprogram/
            |
            ---> org/  
                  |
                  ---> mypackage/
                           |
                           ---> HelloWorld.class       
                           ---> SupportClass.class   
                           ---> UtilClass.class 
</code>

When we invoke Java, we specify the name of the application to run: org.mypackage.HelloWorld. However we must also tell Java where to look for the files and directories defining our package. So to launch the program, we use the following command:

<code>
# here -cp means classpath not copy, it sets the path to the packages used in the program
# org.mypackage.HelloWorld is the name of the main class
java -cp /home/user/myprogram org.mypackage.HelloWorld 
</code>

To avoid typing -cp in all java command, we can also set the class path through an environment variable.

In linux OS:

<code>
# set the classpath to /home/user/myprogram
export CLASSPATH=/home/user/myprogram

# If you already have some classpath set, you can do
export CLASSPATH=$CLASSPATH:/home/user/myprogram

# If you want to include the current directory, you can do
export CLASSPATH=/home/user/myprogram:.

# If your program requires an exterior jar file, you can include it also by setting classpath.
# For example, if I have a jar file in /home/user/ext/log4j-1.2.16.jar. And my program requires it.
export CLASSPATh=$CLASSPATH:/home/user/ext/log4j-1.2.16.jar
java org.mypackage.HelloWorld

# We can do the same with in line classpath setting
java -cp /home/user/ext/log4j-1.2.16.jar org.mypackage.HelloWorld

# Starting from java6, we can use wildcard to includes all jar files of one directory
java -classpath '.:/home/user/ext/*' org.mypackage.HelloWorld

</code>

=== Set class path in a jar file ===

Suppose that we have already encapsulated the helloworld app in a jar file(jar creation: https://docs.oracle.com/javase/tutorial/deployment/jar/build.html). And it requires supportLib.jar
The directory structure is as follows:
<code>
/home/user/myprogram
      |
      ---> helloWorld.jar 
      |
      ---> lib/ 
            |
            ---> supportLib1.jar
            ---> supportLib2.jar
</code>

The manifest file defined in helloWorld.jar has this definition:

<code>
Main-Class: org.mypackage.HelloWorld
Class-Path: lib/supportLib1.jar lib/supportLib2.jar
</code>

The manifest file should end with either a newline or carriage return.

The program is launched with the following command:
<code>
java -jar /home/user/myprogram/helloWorld.jar [app arguments]
</code>

This automatically starts org.mypackage.HelloWorld specified in class Main-Class with the arguments. The user cannot replace this class name using the invocation java -jar. Class-Path describes the location of supportLib1.jar and supportLib2 relative to the location of the library helloWorld.jar. Neither absolute file path, which is permitted in -classpath parameter on the command line, nor jar-internal paths are supported. This means that if the main class file is contained in a jar, org/mypackage/HelloWorld.class must be a valid path on the root within the jar.

Note that we use space to separate multiple jar dependencies in manifest file classpath definition.

==== 5. StringBuilder vs StringBuffer ====

^StringBuilder^  StringBuffer^
|Fast|Slow|
|Not thread safe| thread safe|
|Not synchronized| synchronized|



===== Java language syntax basics =====

==== 1. What's the diff between final, finally and finalize ====

1. Final is a keyword to apply restrictions on class, method and variable

  * Final variable value can't be changed
  * Final method can't be overriden
  * Final class can't be inherited


2. Finally is a block to place important code, it will be executed whether exception is handled or not.

3. Finalize is a method which is used to perform clean up processing just before object is garbage collected.


<file java>
final int x=100;

try{  
int x=300;  
}
catch(Exception e){System.out.println(e);}  
finally{System.out.println("finally block is executed")

class FinalizeExample{  
public void finalize(){System.out.println("finalize called");}  
public static void main(String[] args){  
FinalizeExample f1=new FinalizeExample();  
FinalizeExample f2=new FinalizeExample();  
f1=null;  
f2=null;  
System.gc();  
}}  
</file>

===== The basics of JAVA data structure =====

==== 1. Difference between ArrayList, LinkedList and Vector ====

{{:employes:pengfei.liu:java:java-collection-hierarchy.jpeg?400|}}

From the hierarchy diagram, they all implement List interface. Their main difference is their implementation which causes different performance for different operations.

  * ArrayList, is implemented as a resizable array. As more elements are added to ArrayList, its size is increased dynamically. 
  * LinkedList is implemented as a double linked list. Its performance on add and remove is better than Arraylist, but worse on get and set methods. LinkedList, however, also implements Queue interface which adds more methods than ArrayList and Vector, such as offer(), peek(), poll(), etc
  * Vector is similar with ArrayList, but it is synchronized. ArrayList is a better choice if your program is thread-safe. Vector and ArrayList require space as more elements are added. Vector each time doubles its array size, while ArrayList grow 50% of its size each time. 



===== The basics of JAVA multithread =====

==== 1. Thread safety in JAVA ====

<file java ThreadSafety.java>
package org.pengfei.basic;

public class ThreadSafety {

    public static void main(String[] args) throws InterruptedException {

        ProcessingThread pt = new ProcessingThread();
        Thread t1 = new Thread(pt, "t1");
        t1.start();
        Thread t2 = new Thread(pt, "t2");
        t2.start();
        //wait for threads to finish processing
        t1.join();
        t2.join();
        System.out.println("Processing count="+pt.getCount());
    }

}

class ProcessingThread implements Runnable{
    private int count;

    @Override
    public void run() {
        for(int i=1; i < 5; i++){
            processSomething(i);
            count++;
        }
    }

    public int getCount() {
        return this.count;
    }

    private void processSomething(int i) {
        // processing some job
        try {
            Thread.sleep(i*1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
</file>
The above code should show count=8, because each thread count 4 times and we have 2 thread. But, if you run the program, the possible result is 7,8,9. This happens because the count++ is not an atomic operation and two threads are not synchronized, these causeing the data corruption.

Thread safety in java is the process to make our program safe to use in multithreaded environment, there are different ways through which we can make our program thread safe.

  * Synchronization is the easiest and most widely used tool for thread safety in java.
  * Use of Atomic Wrapper classes from java.util.concurrent.atomic package. For example AtomicInteger
  * Use of locks from java.util.concurrent.locks package.
  * Using thread safe collection classes, check this post for usage of ConcurrentHashMap for thread safety.
  * Using volatile keyword with variables to make every thread read the data from memory, not read from thread cache.


===== The basics of JAVA design pattern =====
==== 1. What's the theory of Dynamic proxies ====

proxies are fronts or wrappers that pass function invocation through their own facilities (usually onto real methods)  potentially adding some functionality.

Dynamic proxies allow one single class with one single method to service multiple method calls to arbitrary classes with an arbitrary number of methods. A dynamic proxy can be thought of as a kind of Facade, but one that can pretend to be an implementation of any interface. Under the cover, it routes all method invocations to a single handler  the invoke() method.

An more detail exmaple [[employes:pengfei.liu:java:design_pattern:dynamicproxy|Dynamic Proxy design pattern]]

==== 2. What is java reflection? ====

Reflection in Java is a very powerful concept and it’s of little use in normal programming but it’s the backbone for most of the Java, J2EE frameworks. Some of the frameworks that use java reflection are:

  * JUnit  uses reflection to parse @Test annotation to get the test methods and then invoke it.
  * Spring  dependency injection, read more at Spring Dependency Injection
  * Tomcat web container to forward the request to correct module by parsing their web.xml files and request URI.
  * Eclipse auto completion of method names
  * Struts
  * Hibernate

The list is endless and they all use java reflection because all these frameworks have no knowledge and access of user defined classes, interfaces, their methods etc.

We should not use reflection in normal programming where we already have access to the classes and interfaces because of following drawbacks.

  * Poor Performance  Since java reflection resolve the types dynamically, it involves processing like scanning the classpath to find the class to load, causing slow performance.
  * Security Restrictions  Reflection requires runtime permissions that might not be available for system running under security manager. This can cause you application to fail at runtime because of security manager.
  * Security Issues  Using reflection we can access part of code that we are not supposed to access, for example we can access private fields of a class and change it’s value. This can be a serious security threat and cause your application to behave abnormally.
  * High Maintenance  Reflection code is hard to understand and debug, also any issues with the code can’t be found at compile time because the classes might not be available, making it less flexible and hard to maintain.

